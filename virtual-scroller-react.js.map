{"version":3,"file":"virtual-scroller-react.js","sources":["../modules/shallowEqual.js","../modules/DOM.js","../modules/log.js","../modules/ItemHeights.js","../modules/VirtualScroller.js","../modules/ReactVirtualScroller.js"],"sourcesContent":["// https://github.com/lodash/lodash/issues/2340\n// https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js\n\n/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @providesModule shallowEqual\r\n * @typechecks\r\n * @flow\r\n */\n\n/*eslint-disable no-self-compare */\n'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\r\n * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n */\n\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n/**\r\n * Performs equality by iterating through keys on an object and returning false\r\n * when any key has values which are not strictly equal between the arguments.\r\n * Returns true when the values of all keys are strictly equal.\r\n */\n\n\nexport default function shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (_typeof(objA) !== 'object' || objA === null || _typeof(objB) !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  } // Test for A's keys different from B.\n\n\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n//# sourceMappingURL=shallowEqual.js.map","/**\r\n * Returns the DOM element's `top` and `left` offset relative to the document.\r\n * `document` can potentially have margins so this function takes care of that.\r\n * @param  {object} element\r\n * @return {object} `{ top: number, left: number, width: number, height: number }`\r\n */\nexport function getOffset(element) {\n  // Copied from:\n  // http://stackoverflow.com/questions/5598743/finding-elements-position-relative-to-the-document\n  var onScreenCoordinates = element.getBoundingClientRect();\n  var documentLeftBorderWidth = document.clientLeft || document.body.clientLeft || 0;\n  var documentTopBorderWidth = document.clientTop || document.body.clientTop || 0; // `window.scrollY` and `window.scrollX` aren't supported in Internet Explorer.\n\n  var scrollY = window.pageYOffset;\n  var scrollX = window.pageXOffset;\n  var top = onScreenCoordinates.top + scrollY - documentTopBorderWidth;\n  var left = onScreenCoordinates.left + scrollX - documentLeftBorderWidth;\n  return {\n    top: top,\n    left: left,\n    width: onScreenCoordinates.width,\n    height: onScreenCoordinates.height\n  };\n}\nexport function getScrollY() {\n  // `window.scrollY` is not supported by Internet Explorer.\n  return window.pageYOffset;\n}\nexport function clearElement(element) {\n  while (element.firstChild) {\n    element.removeChild(element.firstChild);\n  }\n}\nexport function getScreenHeight() {\n  return window.innerHeight;\n}\nexport function getScreenBounds() {\n  var height = getScreenHeight();\n  return {\n    // The first pixel of the viewport.\n    top: getScrollY(),\n    // The pixel after the last pixel of the viewport.\n    bottom: getScrollY() + height,\n    height: height\n  };\n}\n//# sourceMappingURL=DOM.js.map","function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nexport default function log() {\n  if (isDebug()) {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (_console = console).log.apply(_console, _toConsumableArray(['[virtual-scroller]'].concat(args)));\n  }\n}\nexport function isDebug() {\n  return typeof window !== 'undefined' && window.VirtualScrollerDebug;\n}\n//# sourceMappingURL=log.js.map","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport log from './log';\n\nvar ItemHeights =\n/*#__PURE__*/\nfunction () {\n  function ItemHeights(getContainerNode, itemsCount, getState) {\n    _classCallCheck(this, ItemHeights);\n\n    this.getContainerNode = getContainerNode;\n    this.getState = getState; // Initialize `measuredItemsHeight`, `firstMeasuredItemIndex` and `lastMeasuredItemIndex`.\n    // For example, if `state` was supplied to `VirtualScroller`.\n\n    this.measuredItemsHeight = 0;\n    var i = 0;\n\n    while (i < getState().itemHeights.length) {\n      if (getState().itemHeights[i] == undefined) {\n        if (this.firstMeasuredItemIndex !== undefined) {\n          this.lastMeasuredItemIndex = i - 1;\n          break;\n        }\n      } else {\n        if (this.firstMeasuredItemIndex === undefined) {\n          this.firstMeasuredItemIndex = i;\n        }\n\n        this.measuredItemsHeight += getState().itemHeights[i];\n      }\n\n      i++;\n    }\n  } // Seems to be no longer used.\n  // getItemHeight(i, firstShownItemIndex) {\n  // \tif (this.get(i)) {\n  // \t\treturn this.get(i)\n  // \t}\n  // \tconst itemHeight = this._getItemHeight(i, firstShownItemIndex)\n  // \tif (itemHeight) {\n  // \t\tthis.set(i, itemHeight)\n  // \t\treturn itemHeight\n  // \t}\n  // \treturn this.getAverage()\n  // }\n\n\n  _createClass(ItemHeights, [{\n    key: \"_getItemHeight\",\n    value: function _getItemHeight(i, firstShownItemIndex) {\n      var container = this.getContainerNode();\n\n      if (container) {\n        var nodeIndex = i - firstShownItemIndex;\n\n        if (nodeIndex >= 0 && nodeIndex < container.childNodes.length) {\n          // `offsetHeight` is not precise enough (doesn't return fractional pixels).\n          // let height = container.childNodes[nodeIndex].offsetHeight\n          return container.childNodes[nodeIndex].getBoundingClientRect().height;\n        }\n      }\n    }\n  }, {\n    key: \"getItemSpacing\",\n    value: function getItemSpacing() {\n      var container = this.getContainerNode();\n\n      if (container) {\n        if (container.childNodes.length > 1) {\n          var firstItem = container.childNodes[0];\n          var secondItem = container.childNodes[1];\n          var firstItemRect = firstItem.getBoundingClientRect();\n          var secondItemRect = secondItem.getBoundingClientRect();\n          var spacing = secondItemRect.top - (firstItemRect.top + firstItemRect.height); // Debugging.\n\n          if (window.VirtualScrollerDebug) {\n            log('Item spacing', spacing);\n          }\n\n          return spacing;\n        }\n      }\n    }\n    /**\r\n     * Updates item heights and item spacing.\r\n     * @param  {number} fromIndex\r\n     * @param  {number} toIndex\r\n     * @param  {number} firstShownItemIndex\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(fromIndex, toIndex, firstShownItemIndex) {\n      if (this.getState().itemSpacing === undefined) {\n        this.getState().itemSpacing = this.getItemSpacing();\n      } // Reset `this.measuredItemsHeight` if it's not a continuous scroll.\n\n\n      if (this.firstMeasuredItemIndex !== undefined) {\n        if (fromIndex > this.lastMeasuredItemIndex + 1 || toIndex < this.firstMeasuredItemIndex - 1) {\n          // The previously measured average item height might still be\n          // more precise if it contains more measured items (\"samples\").\n          this.previousAverageItemHeight = this.averageItemHeight;\n          this.previousAverageItemHeightSamplesCount = this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1; // Reset.\n\n          this.measuredItemsHeight = 0;\n          this.firstMeasuredItemIndex = undefined;\n          this.lastMeasuredItemIndex = undefined;\n        }\n      }\n\n      var previousFirstMeasuredItemIndex = this.firstMeasuredItemIndex;\n      var previousLastMeasuredItemIndex = this.lastMeasuredItemIndex;\n      var firstMeasuredItemIndexHasBeenUpdated = false;\n      var i = fromIndex;\n\n      while (i <= toIndex) {\n        // Recalculate item heights because item height might change\n        // after showing it compared to what it was when hiding it.\n        // For example, a YouTube video might have been expanded\n        // and then the item is hidden and it's state is reset\n        // and when it's shown again the YouTube video is not expanded.\n        // if (this.get(i) === undefined) {\n        var height = this._getItemHeight(i, firstShownItemIndex);\n\n        if (height !== undefined) {\n          this.set(i, height); // Update new items height (before).\n\n          if (previousFirstMeasuredItemIndex === undefined || i < previousFirstMeasuredItemIndex) {\n            this.measuredItemsHeight += height; // Update first measured item index.\n\n            if (!firstMeasuredItemIndexHasBeenUpdated) {\n              this.firstMeasuredItemIndex = i;\n              firstMeasuredItemIndexHasBeenUpdated = true;\n            }\n          } // Update new items height (after).\n\n\n          if (previousLastMeasuredItemIndex === undefined || i > previousLastMeasuredItemIndex) {\n            // If `previousLastMeasuredItemIndex` is `undefined`\n            // then `previousFirstMeasuredItemIndex` is also `undefined`\n            // which means that `this.measuredItemsHeight` has already been updated.\n            if (previousLastMeasuredItemIndex !== undefined) {\n              this.measuredItemsHeight += height;\n            } // Update last measured item index.\n\n\n            this.lastMeasuredItemIndex = i;\n          }\n        } // }\n\n\n        i++;\n      } // Update average item height.\n\n\n      this.updateAverageItemHeight();\n    }\n  }, {\n    key: \"updateItemHeight\",\n    value: function updateItemHeight(i, firstShownItemIndex) {\n      var previousHeight = this.get(i);\n\n      var height = this._getItemHeight(i, firstShownItemIndex); // The items might not have rendered at all,\n      // for example, when using React, because\n      // React performs DOM updates asynchronously\n      // and if the user scrolls fast enough\n      // React might not have rendered the item\n      // since it has become visible till it became no longer visible.\n\n\n      if (previousHeight === undefined || height === undefined) {\n        return;\n      }\n\n      this.set(i, height);\n      this.measuredItemsHeight += height - previousHeight;\n    }\n  }, {\n    key: \"updateAverageItemHeight\",\n    value: function updateAverageItemHeight() {\n      this.averageItemHeightSamplesCount = this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1;\n      this.averageItemHeight = this.measuredItemsHeight / this.averageItemHeightSamplesCount;\n    }\n    /* Public API. */\n\n  }, {\n    key: \"getAverage\",\n    value: function getAverage() {\n      // Previously measured average item height might still be\n      // more precise if it contains more measured items (\"samples\").\n      if (this.previousAverageItemHeight) {\n        if (this.previousAverageItemHeightSamplesCount > this.averageItemHeightSamplesCount) {\n          return this.previousAverageItemHeight;\n        }\n      }\n\n      return this.averageItemHeight || 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(i) {\n      return this.getState().itemHeights[i];\n    }\n  }, {\n    key: \"set\",\n    value: function set(i, height) {\n      this.getState().itemHeights[i] = height;\n    }\n  }, {\n    key: \"onPrepend\",\n    value: function onPrepend(count) {\n      if (this.firstMeasuredItemIndex !== undefined) {\n        this.firstMeasuredItemIndex += count;\n        this.lastMeasuredItemIndex += count;\n      }\n    }\n  }]);\n\n  return ItemHeights;\n}();\n\nexport { ItemHeights as default };\n//# sourceMappingURL=ItemHeights.js.map","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport shallowEqual from './shallowEqual';\nimport { getOffset, getScrollY, getScreenHeight, getScreenBounds, clearElement } from './DOM';\nimport ItemHeights from './ItemHeights';\nimport log, { isDebug } from './log';\nvar START_FROM_INDEX = 0;\n\nvar VirtualScroller =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @param  {function} getContainerNode — Returns container DOM `Element`.\r\n   * @param  {any[]} items — Are only used for getting items count and for comparing \"previous\" items to \"next\" items if `.updateItems(newItems)` is called.\r\n   * @param  {Object} [options] — See README.md.\r\n   * @return {VirtualScroller}\r\n   */\n  function VirtualScroller(getContainerNode, items) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, VirtualScroller);\n\n    _defineProperty(this, \"onScroll\", function () {\n      return _this.onUpdateShownItemIndexes({\n        reason: 'scroll'\n      });\n    });\n\n    _defineProperty(this, \"onResize\", function () {\n      return _this.onUpdateShownItemIndexes({\n        reason: 'resize'\n      });\n    });\n\n    _defineProperty(this, \"updateShownItemIndexes\", function (callback) {\n      // // A minor optimization. Just because I can.\n      // let listCoordinates\n      // if (this.listCoordinatesCached) {\n      // \tlistCoordinates = this.listCoordinatesCached\n      // \tthis.listCoordinatesCached = undefined\n      // } else {\n      // \tlistCoordinates = getOffset(this.getContainerNode())\n      // }\n      // const { top, height } = listCoordinates\n      var _getOffset = getOffset(_this.getContainerNode()),\n          top = _getOffset.top,\n          height = _getOffset.height;\n\n      var _getScreenBounds = getScreenBounds(),\n          screenTop = _getScreenBounds.top,\n          screenBottom = _getScreenBounds.bottom; // Set screen top and bottom for current layout.\n\n\n      _this.latestLayoutScreenTopAfterMargin = screenTop - _this.getMargin();\n      _this.latestLayoutScreenBottomAfterMargin = screenBottom + _this.getMargin(); // Find the items which are displayed in the viewport.\n\n      var _this$getItemIndexes = _this.getItemIndexes(screenTop - _this.getMargin(), screenBottom + _this.getMargin(), top, top + height),\n          firstShownItemIndex = _this$getItemIndexes.firstShownItemIndex,\n          lastShownItemIndex = _this$getItemIndexes.lastShownItemIndex,\n          redoLayoutAfterRender = _this$getItemIndexes.redoLayoutAfterRender; // Measure \"before\" items height.\n\n\n      var beforeItemsHeight = _this.getBeforeItemsHeight(firstShownItemIndex, lastShownItemIndex); // Measure \"after\" items height.\n\n\n      var afterItemsHeight = _this.getAfterItemsHeight(firstShownItemIndex, lastShownItemIndex); // Update the heights of items to be hidden on next render.\n      // For example, a user could click a \"Show more\" button,\n      // or an \"Expand YouTube video\" button, which would result\n      // in the list item height changing and `this.itemHeights[i]`\n      // being stale, so it's updated here when hiding the item.\n\n\n      _this.updateWillBeHiddenItemHeightsAndState(firstShownItemIndex, lastShownItemIndex); // Debugging.\n\n\n      log('~ Layout results ~');\n      log('First shown item index', firstShownItemIndex);\n      log('Last shown item index', lastShownItemIndex);\n      log('Before items height', beforeItemsHeight);\n      log('After items height', afterItemsHeight);\n      log('Average item height (for previous layout)', _this.itemHeights.getAverage());\n\n      if (redoLayoutAfterRender) {\n        log('Redo layout after render');\n      } // Optionally preload items to be rendered.\n\n\n      _this.onShowItems(firstShownItemIndex, lastShownItemIndex); // Render.\n\n\n      _this.setState({\n        firstShownItemIndex: firstShownItemIndex,\n        lastShownItemIndex: lastShownItemIndex,\n        beforeItemsHeight: beforeItemsHeight,\n        afterItemsHeight: afterItemsHeight // // Average item height is stored in state to differentiate between\n        // // the initial state and \"anything has been measured already\" state.\n        // averageItemHeight: this.itemHeights.getAverage()\n\n      }, function () {\n        return callback(redoLayoutAfterRender ? 1 : 0);\n      });\n    });\n\n    _defineProperty(this, \"updateShownItemIndexesRecursive\", function () {\n      _this.updateShownItemIndexes(function (status) {\n        if (status === 1) {\n          // Recurse in a timeout to prevent React error:\n          // \"Maximum update depth exceeded.\n          //  This can happen when a component repeatedly calls\n          //  setState inside componentWillUpdate or componentDidUpdate.\n          //  React limits the number of nested updates to prevent infinite loops.\"\n          setTimeout(function () {\n            if (_this.isMounted) {\n              _this.updateShownItemIndexesRecursive();\n            } else {\n              _this.onDoneUpdatingItemIndexes();\n            }\n          });\n        } else {\n          _this.onDoneUpdatingItemIndexes();\n        }\n      });\n    });\n\n    _defineProperty(this, \"restoreScroll\", function () {\n      var _this$restoreScrollAf = _this.restoreScrollAfterPrepend,\n          index = _this$restoreScrollAf.index,\n          screenTop = _this$restoreScrollAf.screenTop;\n      _this.restoreScrollAfterPrepend = undefined;\n\n      var newScreenTop = _this.getItemElement(index).getBoundingClientRect().top;\n\n      var scrollByY = newScreenTop - screenTop;\n\n      if (scrollByY !== 0) {\n        log('Restore scroll position: scroll by', scrollByY);\n        window.scrollTo(0, getScrollY() + scrollByY);\n      }\n    });\n\n    _defineProperty(this, \"onUpdateShownItemIndexes\", function (_ref) {\n      var reason = _ref.reason,\n          force = _ref.force;\n\n      // Not implementing the \"delayed\" layout feature for now.\n      // if (this.delayLayout({ reason, force })) {\n      // \treturn\n      // }\n      //\n      // If there're no items then no need to calculate the layout:\n      // if empty `items` have been set on `state` then it has rendered nothing.\n      if (_this.getItemsCount() === 0) {\n        return;\n      } // If a re-layout is already scheduled then it will happen anyway\n      // for the same `state` so there's no need to start another one.\n\n\n      if (_this.isUpdatingItemIndexes) {\n        return;\n      } // Prefer not re-rendering the list as the user's scrolling.\n      // Instead, prefer delaying such re-renders until the user stops scrolling.\n      //\n      // If the user has scrolled then it means that they haven't\n      // stopped scrolling so cancel the timeout.\n      // Otherwise, a layout happens so no need for the deferred one\n      // so cancel the timeout anyway.\n\n\n      clearTimeout(_this.onUserStopsScrollingTimeout); //\n\n      if (reason === 'scroll') {\n        // See whether rendering new previous/next items is required right now\n        // or it can be deferred until the user stops scrolling for better perceived performance.\n        // const listCoordinates = getOffset(this.getContainerNode())\n        // const { top, height } = listCoordinates\n        // const bottom = top + height\n        // const { top: screenTop, bottom: screenBottom } = getScreenBounds()\n        // const renderedItemsTop = top + this.getState().beforeItemsHeight\n        // const renderedItemsBottom = top + height - this.getState().afterItemsHeight\n        // const forceRender = (screenTop < renderedItemsTop && this.getState().firstShownItemIndex > 0) ||\n        // \t(screenBottom > renderedItemsBottom && this.getState().lastShownItemIndex < this.getItemsCount() - 1)\n        var forceRender = // If the items have been rendered at least one\n        _this.latestLayoutScreenTopAfterMargin !== undefined && // If the user has scrolled up past the extra \"margin\"\n        getScrollY() < _this.latestLayoutScreenTopAfterMargin && // and if there're any previous non-rendered items to render.\n        _this.getState().firstShownItemIndex > 0 || // If the items have been rendered at least one\n        _this.latestLayoutScreenBottomAfterMargin !== undefined && // If the user has scrolled down past the extra \"margin\"\n        getScrollY() + getScreenHeight() > _this.latestLayoutScreenBottomAfterMargin && // and if there're any next non-rendered items to render.\n        _this.getState().lastShownItemIndex < _this.getItemsCount() - 1;\n\n        if (forceRender) {\n          log('The user has scrolled far enough: force re-render');\n        } else {\n          log('The user hasn\\'t scrolled too much: delay re-render');\n        } // \"scroll\" events are usually dispatched every 16 milliseconds\n        // for the 60fps refresh rate, so waiting for 100 milliseconds\n        // is about 6 frames of inactivity which would definitely mean\n        // that either the user's no longer scrolling or the browser's\n        // stuttering (skipping frames due to high load) anyway.\n\n\n        if (!forceRender) {\n          return _this.onUserStopsScrollingTimeout = setTimeout(_this.onUserStoppedScrolling, 100);\n        }\n      } // // A minor optimization. Just because I can.\n      // this.listCoordinatesCached = listCoordinates\n      // Re-render the list.\n\n\n      _this.updateLayout(reason);\n    });\n\n    _defineProperty(this, \"onUserStoppedScrolling\", function () {\n      if (_this.isMounted) {\n        // Re-render the list.\n        _this.updateLayout('stopped scrolling');\n      }\n    });\n\n    var getState = options.getState,\n        setState = options.setState,\n        onStateChange = options.onStateChange;\n    var estimatedItemHeight = options.estimatedItemHeight,\n        onLastSeenItemIndexChange = options.onLastSeenItemIndexChange,\n        state = options.state;\n    log('~ Initialize ~'); // If `state` is passed then use `items` from `state`\n    // instead of the `items` argument.\n\n    if (state) {\n      items = state.items;\n    } // if (margin === undefined) {\n    // \t// Renders items which are outside of the screen by this \"margin\".\n    // \t// Is the screen height by default: seems to be the optimal value\n    // \t// for \"Page Up\" / \"Page Down\" navigation and optimized mouse wheel scrolling.\n    // \tmargin = typeof window === 'undefined' ? 0 : window.innerHeight\n    // }\n\n\n    this.initialItems = items; // this.margin = margin\n\n    this.estimatedItemHeight = estimatedItemHeight; // this.getItemState = getItemState\n\n    if (onLastSeenItemIndexChange) {\n      this.onLastSeenItemIndexChange = onLastSeenItemIndexChange;\n      this.lastSeenItemIndex = -1;\n    } // Remove accidental text nodes from container.\n    // Also guards against cases when someone accidentally tries\n    // using `VirtualScroller` on a non-empty element.\n\n\n    if (getContainerNode()) {\n      clearElement(getContainerNode());\n    }\n\n    if (setState) {\n      this.getState = getState;\n      this.setState = setState;\n    } else {\n      this.getState = function () {\n        return _this.state;\n      };\n\n      this.setState = function (state, callback) {\n        var prevState = _this.state;\n        _this.state = _objectSpread({}, prevState, state);\n\n        if (!shallowEqual(_this.state, prevState)) {\n          if (onStateChange) {\n            onStateChange(_this.state, prevState);\n          }\n\n          if (_this.isMounted) {\n            _this.onUpdate(prevState);\n          }\n        }\n\n        if (callback) {\n          callback();\n        }\n      };\n    }\n\n    if (state) {\n      log('Initial state (passed)', state);\n    }\n\n    this.setState(state || this.getInitialState());\n    this.getContainerNode = getContainerNode;\n    this.itemHeights = new ItemHeights(getContainerNode, items.length, this.getState);\n    log('Items count', items.length); // log('Start from index', START_FROM_INDEX)\n\n    if (estimatedItemHeight) {\n      log('Estimated item height', estimatedItemHeight);\n    }\n  }\n  /**\r\n   * Returns the initial state of the `VirtualScroller`.\r\n   * @param  {object} [customState] — Any additional \"custom\" state may be stored in `VirtualScroller`'s state. For example, React implementation stores item \"refs\" as \"custom\" state.\r\n   * @return {object}\r\n   */\n\n\n  _createClass(VirtualScroller, [{\n    key: \"getInitialState\",\n    value: function getInitialState(customState) {\n      var firstShownItemIndex;\n      var lastShownItemIndex;\n      var itemsCount = this.initialItems.length; // If there're no items then `firstShownItemIndex` stays `undefined`.\n\n      if (itemsCount > 0) {\n        firstShownItemIndex = Math.min(START_FROM_INDEX, itemsCount - 1);\n        lastShownItemIndex = this.getLastShownItemIndex(firstShownItemIndex, itemsCount);\n      } // Optionally preload items to be rendered.\n\n\n      this.onShowItems(firstShownItemIndex, lastShownItemIndex);\n\n      var state = _objectSpread({}, customState, {\n        items: this.initialItems,\n        itemStates: new Array(itemsCount),\n        itemHeights: new Array(itemsCount),\n        itemSpacing: undefined,\n        beforeItemsHeight: 0,\n        afterItemsHeight: 0,\n        firstShownItemIndex: firstShownItemIndex,\n        lastShownItemIndex: lastShownItemIndex\n      });\n\n      log('Initial state (created)', state);\n      log('First shown item index', firstShownItemIndex);\n      log('Last shown item index', lastShownItemIndex);\n      return state;\n    }\n    /**\r\n     * Returns estimated list item height.\r\n     * (depends on which items have been previously rendered and measured).\r\n     * @return {number}\r\n     */\n\n  }, {\n    key: \"getEstimatedItemHeight\",\n    value: function getEstimatedItemHeight() {\n      return this.itemHeights && this.itemHeights.getAverage() || this.estimatedItemHeight || 0;\n    }\n  }, {\n    key: \"getItemSpacing\",\n    value: function getItemSpacing() {\n      return this.getState().itemSpacing || 0;\n    }\n  }, {\n    key: \"getEstimatedItemsCount\",\n    value: function getEstimatedItemsCount(height) {\n      if (this.getEstimatedItemHeight()) {\n        return Math.ceil((height + this.getItemSpacing()) / (this.getEstimatedItemHeight() + this.getItemSpacing()));\n      } else {\n        return 1;\n      }\n    }\n  }, {\n    key: \"getEstimatedItemsCountOnScreen\",\n    value: function getEstimatedItemsCountOnScreen() {\n      if (typeof window !== 'undefined') {\n        return this.getEstimatedItemsCount(window.innerHeight);\n      } else {\n        return 1;\n      }\n    }\n  }, {\n    key: \"getLastShownItemIndex\",\n    value: function getLastShownItemIndex(firstShownItemIndex, itemsCount) {\n      return Math.min(firstShownItemIndex + (this.getEstimatedItemsCountOnScreen() - 1), itemsCount - 1);\n    }\n  }, {\n    key: \"getItemsCount\",\n    value: function getItemsCount() {\n      return this.getState().items.length;\n    }\n  }, {\n    key: \"getMargin\",\n    value: function getMargin() {\n      // Renders items which are outside of the screen by this \"margin\".\n      // Is the screen height by default: seems to be the optimal value\n      // for \"Page Up\" / \"Page Down\" navigation and optimized mouse wheel scrolling.\n      return window.innerHeight;\n    }\n  }, {\n    key: \"onShowItems\",\n    value: function onShowItems(firstShownItemIndex, lastShownItemIndex) {\n      if (this.onLastSeenItemIndexChange) {\n        if (lastShownItemIndex > this.lastSeenItemIndex) {\n          this.lastSeenItemIndex = lastShownItemIndex;\n          this.onLastSeenItemIndexChange(this.lastSeenItemIndex);\n        }\n      }\n    }\n  }, {\n    key: \"onMount\",\n    value: function onMount() {\n      var _this$getState = this.getState(),\n          firstShownItemIndex = _this$getState.firstShownItemIndex,\n          lastShownItemIndex = _this$getState.lastShownItemIndex; // If there're any items.\n\n\n      if (this.getItemsCount() > 0) {\n        // Update item heights.\n        this.updateItemHeights(firstShownItemIndex, lastShownItemIndex);\n      }\n\n      this.isMounted = true;\n      this.onUpdateShownItemIndexes({\n        reason: 'on mount'\n      });\n      window.addEventListener('scroll', this.onScroll);\n      window.addEventListener('resize', this.onResize);\n    }\n  }, {\n    key: \"onUnmount\",\n    value: function onUnmount() {\n      this.isMounted = false;\n      window.removeEventListener('scroll', this.onScroll);\n      window.removeEventListener('resize', this.onResize);\n      clearTimeout(this.onUserStopsScrollingTimeout);\n    }\n  }, {\n    key: \"onUpdate\",\n    value: function onUpdate(prevState) {\n      var _this$getState2 = this.getState(),\n          items = _this$getState2.items,\n          firstShownItemIndex = _this$getState2.firstShownItemIndex,\n          lastShownItemIndex = _this$getState2.lastShownItemIndex; // If new items are shown (or older items are hidden).\n\n\n      if (firstShownItemIndex !== prevState.firstShownItemIndex || lastShownItemIndex !== prevState.lastShownItemIndex || items !== prevState.items) {\n        // Update seen item heights.\n        this.updateItemHeights(firstShownItemIndex, lastShownItemIndex);\n      }\n    }\n  }, {\n    key: \"updateItemHeights\",\n    value: function updateItemHeights(fromIndex, toIndex) {\n      var _this$getState3 = this.getState(),\n          firstShownItemIndex = _this$getState3.firstShownItemIndex;\n\n      if (fromIndex !== undefined) {\n        this.itemHeights.update(fromIndex, toIndex, firstShownItemIndex);\n      }\n    }\n  }, {\n    key: \"updateItemHeight\",\n    value: function updateItemHeight(i) {\n      var _this$getState4 = this.getState(),\n          firstShownItemIndex = _this$getState4.firstShownItemIndex;\n\n      this.itemHeights.updateItemHeight(i, firstShownItemIndex);\n    }\n  }, {\n    key: \"onItemStateChange\",\n    value: function onItemStateChange(i, itemState) {\n      if (isDebug()) {\n        log('Item', i, 'state changed');\n        log('Previous state' + '\\n' + JSON.stringify(this.getState().itemStates[i], null, 2));\n        log('New state' + '\\n' + JSON.stringify(itemState, null, 2));\n      }\n\n      this.getState().itemStates[i] = itemState;\n    }\n  }, {\n    key: \"onItemHeightChange\",\n    value: function onItemHeightChange(i) {\n      var _this$getState5 = this.getState(),\n          itemHeights = _this$getState5.itemHeights;\n\n      var previousHeight = itemHeights[i];\n      this.updateItemHeight(i);\n      var newHeight = itemHeights[i];\n\n      if (previousHeight !== newHeight) {\n        log('Item', i, 'height changed from', previousHeight, 'to', newHeight);\n        this.onUpdateShownItemIndexes({\n          reason: 'item height change'\n        });\n      }\n    } // Finds the items which are displayed in the viewport.\n\n  }, {\n    key: \"getVisibleItemIndexes\",\n    value: function getVisibleItemIndexes(screenTop, screenBottom, listTop) {\n      var showItemsFromIndex;\n      var showItemsToIndex;\n      var itemsHeight = 0;\n      var redoLayoutAfterRender = false;\n      var i = START_FROM_INDEX;\n\n      while (i < this.getItemsCount()) {\n        var height = this.itemHeights.get(i); // If an item that hasn't been shown (measured) yet is encountered\n        // then show such item and then retry after it has been measured.\n\n        if (height === undefined) {\n          log(\"Item \".concat(i, \" height hasn't been measured yet: render and redo layout\"));\n\n          if (showItemsFromIndex === undefined) {\n            showItemsFromIndex = i;\n          }\n\n          var heightLeft = screenBottom - (listTop + itemsHeight);\n          var batchSize = this.getEstimatedItemsCount(heightLeft);\n          showItemsToIndex = Math.min(i + (batchSize - 1), // Guard against index overflow.\n          this.getItemsCount() - 1);\n          redoLayoutAfterRender = true;\n          break;\n        }\n\n        itemsHeight += height; // If this is the first item visible\n        // then start showing items from it.\n\n        if (showItemsFromIndex === undefined) {\n          if (listTop + itemsHeight > screenTop) {\n            log('First visible item index (including margin)', i);\n            showItemsFromIndex = i;\n          }\n        } // Items can have spacing.\n\n\n        if (i < this.getItemsCount() - 1) {\n          itemsHeight += this.getItemSpacing();\n        } // If this item is the last one visible in the viewport then exit.\n\n\n        if (listTop + itemsHeight > screenBottom) {\n          log('Last visible item index (including margin)', i); // The list height is estimated until all items have been seen,\n          // so it's possible that even when the list DOM element happens\n          // to be in the viewport in reality the list isn't visible\n          // in which case `showItemsFromIndex` will be `undefined`.\n\n          if (showItemsFromIndex !== undefined) {\n            showItemsToIndex = i;\n          }\n\n          break;\n        }\n\n        i++;\n      } // If there're no more items then the last item is the last one to show.\n\n\n      if (showItemsFromIndex !== undefined && showItemsToIndex === undefined) {\n        showItemsToIndex = this.getItemsCount() - 1;\n        log('Last item index (is fully visible)', showItemsToIndex);\n      } // If scroll position is scheduled to be restored\n      // after render then the anchor item must be rendered\n      // and all the prepended items before it.\n\n\n      if (this.restoreScrollAfterPrepend) {\n        if (showItemsToIndex < this.restoreScrollAfterPrepend.index) {\n          showItemsToIndex = this.restoreScrollAfterPrepend.index;\n        } // No need to redo layout after render because all\n        // prepended items are rendered in a single pass.\n        // It removes the visual jitter otherwise happening\n        // due to scroll position restoration waiting for\n        // two layout cycles instead of one.\n\n\n        redoLayoutAfterRender = false;\n      }\n\n      return {\n        firstShownItemIndex: showItemsFromIndex,\n        lastShownItemIndex: showItemsToIndex,\n        redoLayoutAfterRender: redoLayoutAfterRender\n      };\n    }\n  }, {\n    key: \"getInvisibleItemIndexes\",\n    value: function getInvisibleItemIndexes() {\n      var i = START_FROM_INDEX;\n      return {\n        firstShownItemIndex: i,\n        lastShownItemIndex: i,\n        redoLayoutAfterRender: this.itemHeights.get(i) === undefined\n      };\n    }\n  }, {\n    key: \"getItemIndexes\",\n    value: function getItemIndexes(screenTop, screenBottom, top, bottom) {\n      var isVisible = bottom > screenTop && top < screenBottom;\n\n      if (!isVisible) {\n        return this.getInvisibleItemIndexes();\n      } // Find the items which are displayed in the viewport.\n\n\n      var indexes = this.getVisibleItemIndexes(screenTop, screenBottom, top); // The list height is estimated until all items have been seen,\n      // so it's possible that even when the list DOM element happens\n      // to be in the viewport in reality the list isn't visible\n      // in which case `firstShownItemIndex` will be `undefined`.\n\n      if (indexes.firstShownItemIndex === undefined) {\n        return this.getInvisibleItemIndexes();\n      }\n\n      return indexes;\n    }\n    /**\r\n     * Measures \"before\" items height.\r\n     * @param  {number} firstShownItemIndex — New first shown item index.\r\n     * @param  {number} lastShownItemIndex — New last shown item index.\r\n     * @return {number}\r\n     */\n\n  }, {\n    key: \"getBeforeItemsHeight\",\n    value: function getBeforeItemsHeight(firstShownItemIndex, lastShownItemIndex) {\n      var beforeItemsHeight = 0; // Add all \"before\" items height.\n\n      var i = START_FROM_INDEX;\n\n      while (i < firstShownItemIndex) {\n        beforeItemsHeight += this.itemHeights.get(i) || this.itemHeights.getAverage();\n        beforeItemsHeight += this.getItemSpacing();\n        i++;\n      }\n\n      return beforeItemsHeight;\n    }\n    /**\r\n     * Measures \"after\" items height.\r\n     * @param  {number} firstShownItemIndex — New first shown item index.\r\n     * @param  {number} lastShownItemIndex — New last shown item index.\r\n     * @return {number}\r\n     */\n\n  }, {\n    key: \"getAfterItemsHeight\",\n    value: function getAfterItemsHeight(firstShownItemIndex, lastShownItemIndex) {\n      var afterItemsHeight = 0;\n      var i = lastShownItemIndex + 1; // Add all \"after\" items height.\n\n      while (i < this.getItemsCount()) {\n        afterItemsHeight += this.getItemSpacing();\n        afterItemsHeight += this.itemHeights.get(i) || this.itemHeights.getAverage();\n        i++;\n      }\n\n      return afterItemsHeight;\n    }\n    /**\r\n     * Updates the heights of items to be hidden on next render.\r\n     * For example, a user could click a \"Show more\" button,\r\n     * or an \"Expand YouTube video\" button, which would result\r\n     * in the list item height changing and `this.itemHeights[i]`\r\n     * being stale, so it's updated here when hiding the item.\r\n     */\n\n  }, {\n    key: \"updateWillBeHiddenItemHeightsAndState\",\n    value: function updateWillBeHiddenItemHeightsAndState(firstShownItemIndex, lastShownItemIndex) {\n      var i = this.getState().firstShownItemIndex;\n\n      while (i <= this.getState().lastShownItemIndex) {\n        if (i >= firstShownItemIndex && i <= lastShownItemIndex) {// The item's still visible.\n        } else {\n          // Update item's height before hiding it\n          // because the height of the item may have changed\n          // while it was visible.\n          this.updateItemHeight(i); // // Update item's state because it's about to be hidden.\n          // if (this.getItemState) {\n          // \tthis.getState().itemStates[i] = this.getItemState(\n          // \t\tthis.getState().items[i],\n          // \t\ti,\n          // \t\tthis.getState().items\n          // \t)\n          // }\n        }\n\n        i++;\n      }\n    }\n    /**\r\n     * Updates the \"from\" and \"to\" shown item indexes.\r\n     * `callback(status)` is called after it re-renders.\r\n     * If the list isn't visible then `status` is `-1`.\r\n     * If the list is visible and some of the items being shown\r\n     * are new and required to be measured first then `status` is `1`.\r\n     * If the list is visible and all items being shown\r\n     * have been encountered (and measured) before then `status` is `0`.\r\n     * @param {Function} callback\r\n     */\n\n  }, {\n    key: \"onDoneUpdatingItemIndexes\",\n    value: function onDoneUpdatingItemIndexes() {\n      this.isUpdatingItemIndexes = false;\n\n      if (this.restoreScrollAfterPrepend) {\n        this.restoreScroll();\n      }\n    }\n  }, {\n    key: \"captureScroll\",\n    value: function captureScroll(previousItems, nextItems, firstPreviousItemIndex) {\n      // If there were no items in the list\n      // then there's no point in restoring scroll position.\n      if (previousItems.length === 0) {\n        return;\n      }\n\n      if (firstPreviousItemIndex === undefined) {\n        firstPreviousItemIndex = nextItems.indexOf(previousItems[0]);\n      } // If the items update wasn't incremental\n      // then there's no point in restoring scroll position.\n\n\n      if (firstPreviousItemIndex < 0) {\n        return;\n      } // If no items were prepended then no need to restore scroll position.\n\n\n      if (firstPreviousItemIndex === 0) {\n        return;\n      } // The first item DOM Element must be rendered in order to get its top position.\n\n\n      if (this.getState().firstShownItemIndex > 0) {\n        return;\n      } // If the scroll position for these `previousItems` -> `nextItems`\n      // has already been captured then skip.\n      // This could happen when using `<ReactVirtualScroller/>`\n      // because it calls `.captureScroll()` inside `.render()`\n      // which is followed by `<VirtualScroller/>`'s `.componentDidUpdate()`\n      // which also alls `.captureScroll()` with the same arguments.\n      // (this is done to prevent scroll Y position from jumping\n      //  when showing the first page of the \"Previous items\",\n      //  see the comments in `<ReactVirtualScroller/>`'s `.render()` method).\n\n\n      if (this.restoreScrollAfterPrepend && this.restoreScrollAfterPrepend.previousItems === previousItems && this.restoreScrollAfterPrepend.nextItems === nextItems) {\n        return;\n      }\n\n      this.restoreScrollAfterPrepend = {\n        previousItems: previousItems,\n        nextItems: nextItems,\n        index: firstPreviousItemIndex,\n        screenTop: this.getItemElement(0).getBoundingClientRect().top\n      };\n    }\n  }, {\n    key: \"updateLayout\",\n    value: function updateLayout(reason) {\n      log(\"~ Update layout (\".concat(reason, \") ~\"));\n      this.isUpdatingItemIndexes = true;\n      this.updateShownItemIndexesRecursive();\n    }\n  }, {\n    key: \"updateItems\",\n\n    /**\r\n     * Updates `items`. Can either prepend or append new items to the list.\r\n     * @param  {any[]} newItems\r\n     * @param  {object} [newCustomState] — If `customState` was passed to `getInitialState()`, this `newCustomState` updates it.\r\n     */\n    value: function updateItems(newItems, newCustomState) {\n      var _this2 = this;\n\n      var _this$getState6 = this.getState(),\n          previousItems = _this$getState6.items;\n\n      var _this$getState7 = this.getState(),\n          firstShownItemIndex = _this$getState7.firstShownItemIndex,\n          lastShownItemIndex = _this$getState7.lastShownItemIndex,\n          beforeItemsHeight = _this$getState7.beforeItemsHeight,\n          afterItemsHeight = _this$getState7.afterItemsHeight,\n          itemStates = _this$getState7.itemStates,\n          itemHeights = _this$getState7.itemHeights,\n          itemSpacing = _this$getState7.itemSpacing;\n\n      log('~ Update items ~');\n\n      var _getItemsDiff = getItemsDiff(previousItems, newItems),\n          prependedItemsCount = _getItemsDiff.prependedItemsCount,\n          appendedItemsCount = _getItemsDiff.appendedItemsCount;\n\n      if (prependedItemsCount > 0 || appendedItemsCount > 0) {\n        if (prependedItemsCount > 0) {\n          log('Prepended items count', prependedItemsCount);\n          itemHeights = new Array(prependedItemsCount).concat(itemHeights);\n          this.itemHeights.onPrepend(prependedItemsCount);\n\n          if (itemStates) {\n            itemStates = new Array(prependedItemsCount).concat(itemStates);\n          } // Since some items were prepended restore scroll Y\n          // position after showing those items.\n\n\n          this.captureScroll(previousItems, newItems, prependedItemsCount);\n        }\n\n        if (appendedItemsCount > 0) {\n          log('Appended items count', appendedItemsCount);\n          itemHeights = itemHeights.concat(new Array(appendedItemsCount));\n\n          if (itemStates) {\n            itemStates = itemStates.concat(new Array(appendedItemsCount));\n          }\n        }\n\n        firstShownItemIndex += prependedItemsCount;\n        lastShownItemIndex += prependedItemsCount;\n        beforeItemsHeight += this.itemHeights.getAverage() * prependedItemsCount;\n        afterItemsHeight += this.itemHeights.getAverage() * appendedItemsCount;\n      } else {\n        log('Non-incremental items update');\n        log('Previous items', previousItems);\n        log('New items', newItems);\n        this.itemHeights = new ItemHeights(this.getContainerNode, newItems.length, this.getState);\n        itemHeights = new Array(newItems.length);\n        itemStates = new Array(newItems.length);\n\n        if (newItems.length === 0) {\n          firstShownItemIndex = undefined;\n          lastShownItemIndex = undefined;\n        } else {\n          firstShownItemIndex = 0;\n          lastShownItemIndex = this.getLastShownItemIndex(firstShownItemIndex, newItems.length);\n        }\n\n        beforeItemsHeight = 0;\n        afterItemsHeight = 0;\n      }\n\n      var customState;\n\n      if (newCustomState) {\n        if (typeof newCustomState === 'function') {\n          customState = newCustomState(this.getState(), {\n            prependedCount: isIncrementalUpdate ? undefined : prependedItemsCount,\n            appendedCount: isIncrementalUpdate ? undefined : appendedItemsCount\n          });\n        } else {\n          customState = newCustomState;\n        }\n      }\n\n      this.setState(_objectSpread({}, customState, {\n        items: newItems,\n        itemStates: itemStates,\n        itemHeights: itemHeights,\n        firstShownItemIndex: firstShownItemIndex,\n        lastShownItemIndex: lastShownItemIndex,\n        beforeItemsHeight: beforeItemsHeight,\n        afterItemsHeight: afterItemsHeight\n      }), function () {\n        _this2.onUpdateShownItemIndexes({\n          reason: 'update items',\n          force: true\n        });\n      });\n    }\n  }, {\n    key: \"getItemElement\",\n    value: function getItemElement(i) {\n      return this.getContainerNode().childNodes[i];\n    } // Turns out this optimization won't work\n    // because sometimes item height is an average approximation\n    // and the other times it's the real item height\n    // and sometimes it can change while item's not visible.\n    // /**\n    //  * Measures new \"before\" items height.\n    //  * @param  {number} firstShownItemIndex — New first shown item index.\n    //  * @param  {number} lastShownItemIndex — New last shown item index.\n    //  * @return {number}\n    //  */\n    // getBeforeItemsHeightOptimized(firstShownItemIndex, lastShownItemIndex) {\n    // \t// If the previous and new shown item indexes intersect\n    // \t// then the new \"before\" items height may be calculated\n    // \t// based on the previous \"before\" items height.\n    // \tif (this.getState().averageItemHeight !== undefined &&\n    // \t\tthis.doPrevAndNextItemIndexesIntersect(firstShownItemIndex, lastShownItemIndex)) {\n    // \t\tlet beforeItemsHeight = this.getState().beforeItemsHeight\n    // \t\t// Add all \"before\" will-be-hidden items' height.\n    // \t\tlet i = this.getState().firstShownItemIndex\n    // \t\twhile (i <= this.getState().lastShownItemIndex && i < firstShownItemIndex) {\n    // \t\t\tbeforeItemsHeight += (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tbeforeItemsHeight += this.getItemSpacing()\n    // \t\t\ti++\n    // \t\t}\n    // \t\t// Subtract all \"before\" will-be-shown items' height.\n    // \t\ti = firstShownItemIndex\n    // \t\twhile (i <= lastShownItemIndex && i < this.getState().firstShownItemIndex) {\n    // \t\t\tbeforeItemsHeight -= (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tbeforeItemsHeight -= this.getItemSpacing()\n    // \t\t\ti++\n    // \t\t}\n    // \t\treturn beforeItemsHeight\n    // \t}\n    // \t// If the previous and new shown item indexes don't intersect\n    // \t// then re-calculate \"before\" items height.\n    // \telse {\n    // \t\treturn this.getBeforeItemsHeight(firstShownItemIndex, lastShownItemIndex)\n    // \t}\n    // }\n    // Turns out this optimization won't work\n    // because sometimes item height is an average approximation\n    // and the other times it's the real item height\n    // and sometimes it can change while item's not visible.\n    // /**\n    //  * Measures new \"after\" items height.\n    //  * @param  {number} firstShownItemIndex — New first shown item index.\n    //  * @param  {number} lastShownItemIndex — New last shown item index.\n    //  * @return {number}\n    //  */\n    // getAfterItemsHeightOptimized(firstShownItemIndex, lastShownItemIndex) {\n    // \t// If the previous and new shown item indexes intersect\n    // \t// then the new \"after\" items height may be calculated\n    // \t// based on the previous \"after\" items height.\n    // \tif (this.getState().averageItemHeight !== undefined &&\n    // \t\tthis.doPrevAndNextItemIndexesIntersect(firstShownItemIndex, lastShownItemIndex)) {\n    // \t\tlet afterItemsHeight = this.getState().afterItemsHeight\n    // \t\t// Add all \"after\" will-be-hidden items' height.\n    // \t\tlet i = this.getState().lastShownItemIndex\n    // \t\twhile (i >= this.getState().firstShownItemIndex && i > lastShownItemIndex) {\n    // \t\t\tafterItemsHeight += (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tafterItemsHeight += this.getItemSpacing()\n    // \t\t\ti--\n    // \t\t}\n    // \t\t// Subtract all \"after\" will-be-shown items' height.\n    // \t\ti = lastShownItemIndex\n    // \t\twhile (i >= firstShownItemIndex && i > this.getState().lastShownItemIndex) {\n    // \t\t\tafterItemsHeight -= (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tafterItemsHeight -= this.getItemSpacing()\n    // \t\t\ti--\n    // \t\t}\n    // \t\treturn afterItemsHeight\n    // \t}\n    // \t// If the previous and new shown item indexes don't intersect\n    // \t// then re-calculate \"after\" items height.\n    // \telse {\n    // \t\treturn this.getAfterItemsHeight(firstShownItemIndex, lastShownItemIndex)\n    // \t}\n    // }\n    // Was used it `.getBeforeItemsHeightOptimized()` and `.getAfterItemsHeightOptimized()`.\n    // doPrevAndNextItemIndexesIntersect(firstShownItemIndex, lastShownItemIndex) {\n    // \treturn firstShownItemIndex <= this.getState().lastShownItemIndex &&\n    // \t\tlastShownItemIndex >= this.getState().firstShownItemIndex\n    // }\n    // Not implementing the \"delayed\" layout feature for now.\n    // delayLayout(args) {\n    // \t// Suppose there's a \"router\" library which restores scroll position\n    // \t// on \"Back\" navigation but only does so after `componentDidMount()`\n    // \t// is called on the underlying page meaning that by the time\n    // \t// the scroll position is restored the `VirtualScroller` component\n    // \t// has already rendered with previous page's scroll position\n    // \t// resulting in an unnecessary layout. \"Delaying\" layout\n    // \t// means that the layout is called in a `setTimeout(..., 0)` call\n    // \t// rather than immediately on mount.\n    // \tif (this.shouldDelayLayout) {\n    // \t\tthis.layoutDelayedWithArgs = args\n    // \t\t// Then in `.onMount()`:\n    // \t\t// if (this.layoutDelayedWithArgs) {\n    // \t\t// \tthis.shouldDelayLayout = false\n    // \t\t// \tsetTimeout(() => {\n    // \t\t// \t\tif (this.isMounted) {\n    // \t\t// \t\t\tthis.onUpdateShownItemIndexes(this.layoutDelayedWithArgs)\n    // \t\t// \t\t\tthis.layoutDelayedWithArgs = undefined\n    // \t\t// \t\t}\n    // \t\t// \t}, 0)\n    // \t\t// }\n    // \t\treturn true\n    // \t}\n    // }\n\n  }]);\n\n  return VirtualScroller;\n}();\n\nexport { VirtualScroller as default };\n\nfunction getRemainderRest(n, divider) {\n  var remainder = n % divider;\n\n  if (remainder > 0) {\n    return divider - remainder;\n  }\n\n  return 0;\n}\n\nexport function getItemsDiff(previousItems, newItems) {\n  var firstPreviousItemIndex = -1;\n  var lastPreviousItemIndex = -1;\n\n  if (previousItems.length > 0) {\n    firstPreviousItemIndex = newItems.indexOf(previousItems[0]);\n\n    if (firstPreviousItemIndex >= 0) {\n      if (newItems.length >= firstPreviousItemIndex + previousItems.length && newItems[firstPreviousItemIndex + previousItems.length - 1] === previousItems[previousItems.length - 1]) {\n        lastPreviousItemIndex = firstPreviousItemIndex + previousItems.length - 1;\n      }\n    }\n  }\n\n  var isIncrementalUpdate = firstPreviousItemIndex >= 0 && lastPreviousItemIndex >= 0;\n\n  if (isIncrementalUpdate) {\n    return {\n      prependedItemsCount: firstPreviousItemIndex,\n      appendedItemsCount: newItems.length - (lastPreviousItemIndex + 1)\n    };\n  }\n\n  return {\n    prependedItemsCount: -1,\n    appendedItemsCount: -1\n  };\n}\n//# sourceMappingURL=VirtualScroller.js.map","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport VirtualScroller, { getItemsDiff } from './VirtualScroller';\nimport shallowEqual from './shallowEqual'; // `PropTypes.elementType` is available in some version of `prop-types`.\n// https://github.com/facebook/prop-types/issues/200\n\nvar elementType = PropTypes.elementType || PropTypes.oneOfType([PropTypes.func, PropTypes.object]);\n\nvar ReactVirtualScroller =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(ReactVirtualScroller, _React$Component);\n\n  // Handler function caches.\n  // Just so that the props passed to `itemComponent`\n  // are not changed on every `.render()` and so\n  // `itemComponent` won't re-render if it's a `PureComponent`.\n  // List items are rendered with `key`s\n  // so that React doesn't reuse `itemComponent`s\n  // in cases when `items` are changed.\n  function ReactVirtualScroller(props) {\n    var _this;\n\n    _classCallCheck(this, ReactVirtualScroller);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactVirtualScroller).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"container\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"onItemStateChange\", new Array(_this.props.items.length));\n\n    _defineProperty(_assertThisInitialized(_this), \"onItemHeightChange\", new Array(_this.props.items.length));\n\n    _defineProperty(_assertThisInitialized(_this), \"uniquePrefixes\", []);\n\n    var _this$props = _this.props,\n        items = _this$props.items,\n        initialState = _this$props.initialState,\n        estimatedItemHeight = _this$props.estimatedItemHeight,\n        onLastSeenItemIndexChange = _this$props.onLastSeenItemIndexChange,\n        onStateChange = _this$props.onStateChange; // `this.previousItems` are only used for comparing\n    // `previousItems` with `newItems` in `render()`.\n\n    _this.previousItems = items; // Create `virtual-scroller` instance.\n\n    _this.virtualScroller = new VirtualScroller(function () {\n      return _this.container.current;\n    }, items, {\n      estimatedItemHeight: estimatedItemHeight,\n      onLastSeenItemIndexChange: onLastSeenItemIndexChange,\n      state: initialState,\n      getState: function getState() {\n        return _this.state;\n      },\n      setState: function setState(newState, callback) {\n        if (_this.state) {\n          // Update existing state.\n          _this.setState(newState, callback);\n        } else {\n          // Set initial state.\n          _this.state = newState;\n\n          if (onStateChange) {\n            onStateChange(newState);\n          }\n        }\n      }\n    }); // Generate unique `key` prefix for list item components.\n\n    _this.generateUniquePrefix();\n\n    return _this;\n  }\n\n  _createClass(ReactVirtualScroller, [{\n    key: \"getOnItemStateChange\",\n    value: function getOnItemStateChange(i) {\n      var _this2 = this;\n\n      if (!this.onItemStateChange[i]) {\n        this.onItemStateChange[i] = function (itemState) {\n          return _this2.virtualScroller.onItemStateChange(i, itemState);\n        };\n      }\n\n      return this.onItemStateChange[i];\n    }\n  }, {\n    key: \"getOnItemHeightChange\",\n    value: function getOnItemHeightChange(i) {\n      var _this3 = this;\n\n      if (!this.onItemHeightChange[i]) {\n        this.onItemHeightChange[i] = function () {\n          return _this3.virtualScroller.onItemHeightChange(i);\n        };\n      }\n\n      return this.onItemHeightChange[i];\n    }\n  }, {\n    key: \"generateUniquePrefix\",\n    value: function generateUniquePrefix() {\n      var prefix = String(Math.random()).slice(2);\n\n      if (this.uniquePrefixes.indexOf(prefix) >= 0) {\n        return this.generateUniquePrefix();\n      }\n\n      this.uniquePrefixes.push(prefix);\n      this.uniquePrefix = prefix;\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var onMount = this.props.onMount; // `onMount()` should be called before `VirtualScroller`'s\n      // in order for it to be able to be used for restoring\n      // page scroll Y position.\n\n      if (onMount) {\n        onMount();\n      }\n\n      this.virtualScroller.onMount();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this$props2 = this.props,\n          items = _this$props2.items,\n          onStateChange = _this$props2.onStateChange;\n      this.virtualScroller.onUpdate(prevState);\n\n      if (items !== prevProps.items) {\n        this.virtualScroller.updateItems(items);\n      }\n\n      if (onStateChange) {\n        if (!shallowEqual(this.state, prevState)) {\n          onStateChange(this.state, prevState);\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.virtualScroller.onUnmount();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var _this$props3 = this.props,\n          Component = _this$props3.itemComponent,\n          itemComponentProps = _this$props3.itemComponentProps,\n          _items = _this$props3.items,\n          estimatedItemHeight = _this$props3.estimatedItemHeight,\n          initialState = _this$props3.initialState,\n          onStateChange = _this$props3.onStateChange,\n          onLastSeenItemIndexChange = _this$props3.onLastSeenItemIndexChange,\n          onMount = _this$props3.onMount,\n          rest = _objectWithoutProperties(_this$props3, [\"itemComponent\", \"itemComponentProps\", \"items\", \"estimatedItemHeight\", \"initialState\", \"onStateChange\", \"onLastSeenItemIndexChange\", \"onMount\"]);\n\n      var _this$virtualScroller = this.virtualScroller.getState(),\n          items = _this$virtualScroller.items,\n          itemStates = _this$virtualScroller.itemStates,\n          firstShownItemIndex = _this$virtualScroller.firstShownItemIndex,\n          lastShownItemIndex = _this$virtualScroller.lastShownItemIndex,\n          beforeItemsHeight = _this$virtualScroller.beforeItemsHeight,\n          afterItemsHeight = _this$virtualScroller.afterItemsHeight; // If `items` are about to be changed then\n      // store the scroll Y position for the first one\n      // of the current items.\n      // Previously it was being done in `componentDidUpdate()`\n      // but it was later found out that it wouldn't work\n      // for \"Show previous\" button because it would\n      // get hidden before `componentDidUpdate()` is called.\n      //\n      // Consider this code example:\n      //\n      // const { fromIndex, items } = this.state\n      // const items = allItems.slice(fromIndex)\n      // return (\n      // \t{fromIndex > 0 &&\n      // \t\t<button onClick={this.onShowPrevious}>\n      // \t\t\tShow previous\n      // \t\t</button>\n      // \t}\n      // \t<VirtualScroller\n      // \t\titems={items}\n      // \t\titemComponent={ItemComponent}/>\n      // )\n      //\n      // Consider a user clicks \"Show previous\" to show the items from the start.\n      // By the time `componentDidUpdate()` is called on `<VirtualScroller/>`\n      // the \"Show previous\" button has already been hidden\n      // which results in the scroll Y position jumping forward\n      // by the height of the \"Show previous\" button.\n      // This is because `<VirtualScroller/>` restores scroll Y position\n      // when items are prepended via `.updateItems()` and it does that\n      // when the \"Show previous\" button has already been hidden\n      // so that's the reason for the scroll Y jump.\n      //\n      // To prevent that, scroll Y position is stored at `render()` time\n      // rather than later in `componentDidUpdate()`.\n      //\n\n\n      var newItems = this.props.items; // `this.state` is already reserved for `virtual-scroller`.\n      // const previousItems = this.state.prevProps.items\n\n      var previousItems = this.previousItems;\n      this.previousItems = newItems; // Comparing `this.props.items` to `this.virtualScroller.getState().items`\n      // won't work for cases when `initialState.items` are passed.\n\n      if (newItems !== previousItems) {\n        var _getItemsDiff = getItemsDiff(previousItems, newItems),\n            prependedItemsCount = _getItemsDiff.prependedItemsCount,\n            appendedItemsCount = _getItemsDiff.appendedItemsCount;\n\n        if (prependedItemsCount === 0 && appendedItemsCount > 0) {// If it's just items that have been appended\n          // then no need to re-generate the prefix\n          // and to fix scroll position and to clear caches.\n        } else {\n          this.generateUniquePrefix();\n          this.virtualScroller.captureScroll(previousItems, newItems); // Reset handler function caches.\n\n          this.onItemStateChange = new Array(newItems.length);\n          this.onItemHeightChange = new Array(newItems.length);\n        }\n      }\n\n      return React.createElement(\"div\", _extends({}, rest, {\n        ref: this.container,\n        style: {\n          paddingTop: beforeItemsHeight + 'px',\n          paddingBottom: afterItemsHeight + 'px'\n        }\n      }), items.map(function (item, i) {\n        if (i >= firstShownItemIndex && i <= lastShownItemIndex) {\n          return React.createElement(Component, _extends({}, itemComponentProps, {\n            key: \"\".concat(_this4.uniquePrefix, \":\").concat(i),\n            state: itemStates && itemStates[i],\n            onStateChange: _this4.getOnItemStateChange(i),\n            onHeightChange: _this4.getOnItemHeightChange(i)\n          }), item);\n        }\n\n        return null;\n      }));\n    }\n  }]);\n\n  return ReactVirtualScroller;\n}(React.Component);\n\n_defineProperty(ReactVirtualScroller, \"propTypes\", {\n  items: PropTypes.arrayOf(PropTypes.object).isRequired,\n  itemComponent: elementType.isRequired,\n  itemComponentProps: PropTypes.object,\n  estimatedItemHeight: PropTypes.number,\n  onMount: PropTypes.func,\n  onLastSeenItemIndexChange: PropTypes.func,\n  onStateChange: PropTypes.func,\n  initialState: PropTypes.shape({\n    items: PropTypes.arrayOf(PropTypes.object).isRequired,\n    itemStates: PropTypes.arrayOf(PropTypes.any),\n    firstShownItemIndex: PropTypes.number.isRequired,\n    lastShownItemIndex: PropTypes.number.isRequired,\n    beforeItemsHeight: PropTypes.number.isRequired,\n    afterItemsHeight: PropTypes.number.isRequired,\n    itemHeights: PropTypes.arrayOf(PropTypes.number).isRequired,\n    itemSpacing: PropTypes.number\n  }) // `this.state` is already reserved for `virtual-scroller`.\n  // static getDerivedStateFromProps(props, state) {\n  // \treturn {\n  // \t\tprevProps: {\n  // \t\t\titems: props.items\n  // \t\t}\n  // \t}\n  // }\n\n});\n\nexport { ReactVirtualScroller as default };\n//# sourceMappingURL=ReactVirtualScroller.js.map"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","hasOwnProperty","Object","is","x","y","shallowEqual","objA","objB","keysA","keys","keysB","length","i","call","getScrollY","window","pageYOffset","getScreenHeight","innerHeight","_toConsumableArray","arr","Array","isArray","arr2","_arrayWithoutHoles","iter","toString","from","_iterableToArray","TypeError","_nonIterableSpread","log","isDebug","_console","_len","arguments","args","_key","console","apply","concat","VirtualScrollerDebug","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","ItemHeights","getContainerNode","itemsCount","getState","instance","Constructor","_classCallCheck","this","measuredItemsHeight","itemHeights","undefined","firstMeasuredItemIndex","lastMeasuredItemIndex","protoProps","staticProps","value","firstShownItemIndex","container","nodeIndex","childNodes","getBoundingClientRect","height","firstItem","secondItem","firstItemRect","spacing","top","fromIndex","toIndex","itemSpacing","getItemSpacing","previousAverageItemHeight","averageItemHeight","previousAverageItemHeightSamplesCount","previousFirstMeasuredItemIndex","previousLastMeasuredItemIndex","firstMeasuredItemIndexHasBeenUpdated","_getItemHeight","set","updateAverageItemHeight","previousHeight","get","averageItemHeightSamplesCount","count","_objectSpread","source","ownKeys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","forEach","_defineProperty","VirtualScroller","items","_this","options","onUpdateShownItemIndexes","reason","callback","element","onScreenCoordinates","documentLeftBorderWidth","documentTopBorderWidth","scrollY","scrollX","_getOffset","document","clientLeft","body","clientTop","pageXOffset","left","width","_getScreenBounds","bottom","getScreenBounds","screenTop","screenBottom","latestLayoutScreenTopAfterMargin","getMargin","latestLayoutScreenBottomAfterMargin","_this$getItemIndexes","getItemIndexes","lastShownItemIndex","redoLayoutAfterRender","beforeItemsHeight","getBeforeItemsHeight","afterItemsHeight","getAfterItemsHeight","updateWillBeHiddenItemHeightsAndState","getAverage","onShowItems","setState","updateShownItemIndexes","status","setTimeout","isMounted","updateShownItemIndexesRecursive","onDoneUpdatingItemIndexes","_this$restoreScrollAf","restoreScrollAfterPrepend","index","scrollByY","getItemElement","scrollTo","_ref","force","getItemsCount","isUpdatingItemIndexes","clearTimeout","onUserStopsScrollingTimeout","forceRender","onUserStoppedScrolling","updateLayout","onStateChange","estimatedItemHeight","onLastSeenItemIndexChange","state","initialItems","lastSeenItemIndex","firstChild","removeChild","clearElement","prevState","onUpdate","getInitialState","customState","Math","min","getLastShownItemIndex","itemStates","getEstimatedItemHeight","ceil","getEstimatedItemsCount","getEstimatedItemsCountOnScreen","_this$getState","updateItemHeights","addEventListener","onScroll","onResize","removeEventListener","_this$getState2","update","updateItemHeight","itemState","JSON","stringify","newHeight","listTop","showItemsFromIndex","showItemsToIndex","itemsHeight","heightLeft","batchSize","getInvisibleItemIndexes","indexes","getVisibleItemIndexes","restoreScroll","previousItems","nextItems","firstPreviousItemIndex","indexOf","newItems","newCustomState","_this2","_this$getState7","_getItemsDiff","getItemsDiff","prependedItemsCount","appendedItemsCount","onPrepend","captureScroll","prependedCount","isIncrementalUpdate","appendedCount","lastPreviousItemIndex","_extends","assign","_objectWithoutProperties","excluded","sourceKeys","_objectWithoutPropertiesLoose","sourceSymbolKeys","propertyIsEnumerable","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","p","elementType","PropTypes","oneOfType","func","object","ReactVirtualScroller","_React$Component","React","createRef","_this$props","initialState","virtualScroller","current","newState","generateUniquePrefix","subClass","superClass","create","_inherits","Component","onItemStateChange","_this3","onItemHeightChange","prefix","String","random","slice","uniquePrefixes","push","uniquePrefix","onMount","prevProps","_this$props2","updateItems","onUnmount","_this4","_this$props3","itemComponent","itemComponentProps","rest","_this$virtualScroller","createElement","ref","style","paddingTop","paddingBottom","map","item","getOnItemStateChange","onHeightChange","getOnItemHeightChange","arrayOf","isRequired","number","shape","any"],"mappings":"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"}