{"version":3,"file":"virtual-scroller-react.js","sources":["../modules/shallowEqual.js","../modules/DOM.js","../modules/log.js","../modules/ItemHeights.js","../modules/utility.js","../modules/VirtualScroller.js","../modules/ReactVirtualScroller.js"],"sourcesContent":["// https://github.com/lodash/lodash/issues/2340\n// https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js\n\n/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @providesModule shallowEqual\r\n * @typechecks\r\n * @flow\r\n */\n\n/*eslint-disable no-self-compare */\n'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\r\n * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n */\n\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n/**\r\n * Performs equality by iterating through keys on an object and returning false\r\n * when any key has values which are not strictly equal between the arguments.\r\n * Returns true when the values of all keys are strictly equal.\r\n */\n\n\nexport default function shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (_typeof(objA) !== 'object' || objA === null || _typeof(objB) !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  } // Test for A's keys different from B.\n\n\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n//# sourceMappingURL=shallowEqual.js.map","/**\r\n * Returns the DOM element's `top` and `left` offset relative to the document.\r\n * `document` can potentially have margins so this function takes care of that.\r\n * Calling `getOffset()` on an element is about 0.003 milliseconds on a modern desktop CPU.\r\n * @param  {object} element\r\n * @return {object} `{ top: number, left: number, width: number, height: number }`\r\n */\nexport function getOffset(element) {\n  // Copied from:\n  // http://stackoverflow.com/questions/5598743/finding-elements-position-relative-to-the-document\n  // Calling `.getBoundingClientRect()` on an element is\n  // about 0.002 milliseconds on a modern desktop CPU.\n  var onScreenCoordinates = element.getBoundingClientRect();\n  var documentLeftBorderWidth = document.clientLeft || document.body.clientLeft || 0;\n  var documentTopBorderWidth = document.clientTop || document.body.clientTop || 0; // `window.scrollY` and `window.scrollX` aren't supported in Internet Explorer.\n\n  var scrollY = window.pageYOffset;\n  var scrollX = window.pageXOffset;\n  var top = onScreenCoordinates.top + scrollY - documentTopBorderWidth;\n  var left = onScreenCoordinates.left + scrollX - documentLeftBorderWidth;\n  return {\n    top: top,\n    left: left,\n    width: onScreenCoordinates.width,\n    height: onScreenCoordinates.height\n  };\n}\nexport function getScrollY() {\n  // `window.scrollY` is not supported by Internet Explorer.\n  return window.pageYOffset;\n}\nexport function clearElement(element) {\n  while (element.firstChild) {\n    element.removeChild(element.firstChild);\n  }\n}\nexport function getScreenHeight() {\n  return window.innerHeight;\n}\nexport function getScreenBounds() {\n  var height = getScreenHeight();\n  return {\n    // The first pixel of the viewport.\n    top: getScrollY(),\n    // The pixel after the last pixel of the viewport.\n    bottom: getScrollY() + height,\n    height: height\n  };\n}\n//# sourceMappingURL=DOM.js.map","function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nexport default function log() {\n  if (isDebug()) {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (_console = console).log.apply(_console, _toConsumableArray(['[virtual-scroller]'].concat(args)));\n  }\n}\nexport function isDebug() {\n  return typeof window !== 'undefined' && window.VirtualScrollerDebug;\n}\n//# sourceMappingURL=log.js.map","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport log from './log';\n\nvar ItemHeights =\n/*#__PURE__*/\nfunction () {\n  function ItemHeights(getContainerNode, getState) {\n    _classCallCheck(this, ItemHeights);\n\n    this.getContainerNode = getContainerNode;\n    this.getState = getState;\n    this.reset();\n  }\n\n  _createClass(ItemHeights, [{\n    key: \"reset\",\n    value: function reset() {\n      this.measuredItemsHeight = 0;\n      this.firstMeasuredItemIndex = undefined;\n      this.lastMeasuredItemIndex = undefined; // this.averageItemHeight = undefined\n      // this.averageItemHeightSamplesCount = undefined\n      // this.previousAverageItemHeight = undefined\n      // this.previousAverageItemHeightSamplesCount = undefined\n    }\n    /**\r\n     * Initializes `this.measuredItemsHeight`, `this.firstMeasuredItemIndex` and\r\n     * `this.lastMeasuredItemIndex` instance variables.\r\n     * These instance variables are used when calculating \"average\" item height:\r\n     * the \"average\" item height is simply `this.measuredItemsHeight` divided by\r\n     * `this.lastMeasuredItemIndex` minus `this.firstMeasuredItemIndex` plus 1.\r\n     * Also, `this.firstMeasuredItemIndex` and `this.lastMeasuredItemIndex`\r\n     * are used to detect \"non-continuous\" scroll: the cases when scroll position\r\n     * jumps from one position to a distant another position. How could that happen?\r\n     * Maybe it can't, but just in case.\r\n     */\n\n  }, {\n    key: \"onInitItemHeights\",\n    value: function onInitItemHeights() {\n      this.reset();\n      var i = 0;\n\n      while (i < this.getState().itemHeights.length) {\n        if (this.getState().itemHeights[i] == undefined) {\n          if (this.firstMeasuredItemIndex !== undefined) {\n            this.lastMeasuredItemIndex = i - 1;\n            break;\n          }\n        } else {\n          if (this.firstMeasuredItemIndex === undefined) {\n            this.firstMeasuredItemIndex = i;\n          }\n\n          this.measuredItemsHeight += this.getState().itemHeights[i];\n        }\n\n        i++;\n      }\n    } // Seems to be no longer used.\n    // getItemHeight(i, firstShownItemIndex) {\n    // \tif (this.get(i)) {\n    // \t\treturn this.get(i)\n    // \t}\n    // \tconst itemHeight = this._getItemHeight(i, firstShownItemIndex)\n    // \tif (itemHeight) {\n    // \t\tthis.set(i, itemHeight)\n    // \t\treturn itemHeight\n    // \t}\n    // \treturn this.getAverage()\n    // }\n\n  }, {\n    key: \"_getItemHeight\",\n    value: function _getItemHeight(i, firstShownItemIndex) {\n      var container = this.getContainerNode();\n\n      if (container) {\n        var nodeIndex = i - firstShownItemIndex;\n\n        if (nodeIndex >= 0 && nodeIndex < container.childNodes.length) {\n          // `offsetHeight` is not precise enough (doesn't return fractional pixels).\n          // let height = container.childNodes[nodeIndex].offsetHeight\n          return container.childNodes[nodeIndex].getBoundingClientRect().height;\n        }\n      }\n    }\n  }, {\n    key: \"getItemSpacing\",\n    value: function getItemSpacing() {\n      var container = this.getContainerNode();\n\n      if (container) {\n        if (container.childNodes.length > 1) {\n          var firstItem = container.childNodes[0];\n          var secondItem = container.childNodes[1];\n          var firstItemRect = firstItem.getBoundingClientRect();\n          var secondItemRect = secondItem.getBoundingClientRect();\n          var spacing = secondItemRect.top - (firstItemRect.top + firstItemRect.height); // Debugging.\n\n          if (window.VirtualScrollerDebug) {\n            log('Item spacing', spacing);\n          }\n\n          return spacing;\n        }\n      }\n    }\n    /**\r\n     * Updates item heights and item spacing.\r\n     * @param  {number} fromIndex\r\n     * @param  {number} toIndex\r\n     * @param  {number} firstShownItemIndex\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(fromIndex, toIndex, firstShownItemIndex) {\n      if (this.getState().itemSpacing === undefined) {\n        this.getState().itemSpacing = this.getItemSpacing();\n      } // Reset `this.measuredItemsHeight` if it's not a continuous scroll.\n\n\n      if (this.firstMeasuredItemIndex !== undefined) {\n        if (fromIndex > this.lastMeasuredItemIndex + 1 || toIndex < this.firstMeasuredItemIndex - 1) {\n          // // The previously measured average item height might still be\n          // // more precise if it contains more measured items (\"samples\").\n          // const previousAverageItemHeight = this.averageItemHeight\n          // const previousAverageItemHeightSamplesCount = this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1\n          // Reset.\n          this.reset(); // this.previousAverageItemHeight = previousAverageItemHeight\n          // this.previousAverageItemHeightSamplesCount = previousAverageItemHeightSamplesCount\n        }\n      }\n\n      var previousFirstMeasuredItemIndex = this.firstMeasuredItemIndex;\n      var previousLastMeasuredItemIndex = this.lastMeasuredItemIndex;\n      var firstMeasuredItemIndexHasBeenUpdated = false;\n      var i = fromIndex;\n\n      while (i <= toIndex) {\n        // Recalculate item heights because item height might change\n        // after showing it compared to what it was when hiding it.\n        // For example, a YouTube video might have been expanded\n        // and then the item is hidden and it's state is reset\n        // and when it's shown again the YouTube video is not expanded.\n        // if (this.get(i) === undefined) {\n        var height = this._getItemHeight(i, firstShownItemIndex);\n\n        if (height !== undefined) {\n          this.set(i, height); // Update new items height (before).\n\n          if (previousFirstMeasuredItemIndex === undefined || i < previousFirstMeasuredItemIndex) {\n            this.measuredItemsHeight += height; // Update first measured item index.\n\n            if (!firstMeasuredItemIndexHasBeenUpdated) {\n              this.firstMeasuredItemIndex = i;\n              firstMeasuredItemIndexHasBeenUpdated = true;\n            }\n          } // Update new items height (after).\n\n\n          if (previousLastMeasuredItemIndex === undefined || i > previousLastMeasuredItemIndex) {\n            // If `previousLastMeasuredItemIndex` is `undefined`\n            // then `previousFirstMeasuredItemIndex` is also `undefined`\n            // which means that `this.measuredItemsHeight` has already been updated.\n            if (previousLastMeasuredItemIndex !== undefined) {\n              this.measuredItemsHeight += height;\n            } // Update last measured item index.\n\n\n            this.lastMeasuredItemIndex = i;\n          }\n        } // }\n\n\n        i++;\n      } // // Update average item height.\n      // this.updateAverageItemHeight()\n\n    }\n    /**\r\n     * Re-measures item height.\r\n     * @param  {number} i — Item index.\r\n     * @param  {number} firstShownItemIndex\r\n     */\n\n  }, {\n    key: \"updateItemHeight\",\n    value: function updateItemHeight(i, firstShownItemIndex) {\n      var previousHeight = this.get(i);\n\n      var height = this._getItemHeight(i, firstShownItemIndex); // The items might not have rendered at all,\n      // for example, when using React, because\n      // React performs DOM updates asynchronously\n      // and if the user scrolls fast enough\n      // React might not have rendered the item\n      // since it has become visible till it became no longer visible.\n\n\n      if (previousHeight === undefined || height === undefined) {\n        return;\n      }\n\n      this.set(i, height);\n      this.measuredItemsHeight += height - previousHeight;\n    } // /**\n    //  * \"Average\" item height is stored as an instance variable.\n    //  * For example, for caching, so that it isn't calculated every time it's requested.\n    //  * But that would be negligible performance gain, not really worth the extra code.\n    //  * Another thing it's stored for as an instance variable is\n    //  * keeping \"previous\" \"average\" item height, because it can be more precise\n    //  * than the newly calculated \"average\" item height, provided it had\n    //  * more \"samples\" (measured items). The newly calculated average item height\n    //  * could get less samples in a scenario when the scroll somehow jumps\n    //  * from one position to some other distant position: in that case previous\n    //  * \"total measured items height\" is discarded and the new one is initialized.\n    //  * Could such situation happen in real life? I guess, it's unlikely.\n    //  * So I'm commenting out this code, but still keeping it just in case.\n    //  */\n    // updateAverageItemHeight() {\n    // \tthis.averageItemHeightSamplesCount = this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1\n    // \tthis.averageItemHeight = this.measuredItemsHeight / this.averageItemHeightSamplesCount\n    // }\n    //\n    // /**\n    //  * Public API: is called by `VirtualScroller`.\n    //  * @return {number}\n    //  */\n    // getAverage() {\n    // \t// Previously measured average item height might still be\n    // \t// more precise if it contains more measured items (\"samples\").\n    // \tif (this.previousAverageItemHeight) {\n    // \t\tif (this.previousAverageItemHeightSamplesCount > this.averageItemHeightSamplesCount) {\n    // \t\t\treturn this.previousAverageItemHeight\n    // \t\t}\n    // \t}\n    // \treturn this.averageItemHeight || 0\n    // }\n\n    /**\r\n     * Public API: is called by `VirtualScroller`.\r\n     * @return {number}\r\n     */\n\n  }, {\n    key: \"getAverage\",\n    value: function getAverage() {\n      // When `this.measuredItemsHeight` is `0`\n      // then `this.lastMeasuredItemIndex` and `this.firstMeasuredItemIndex` are `undefined`.\n      if (this.measuredItemsHeight) {\n        return this.measuredItemsHeight / (this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1);\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(i) {\n      return this.getState().itemHeights[i];\n    }\n  }, {\n    key: \"set\",\n    value: function set(i, height) {\n      this.getState().itemHeights[i] = height;\n    }\n  }, {\n    key: \"onPrepend\",\n    value: function onPrepend(count) {\n      if (this.firstMeasuredItemIndex !== undefined) {\n        this.firstMeasuredItemIndex += count;\n        this.lastMeasuredItemIndex += count;\n      }\n    }\n  }]);\n\n  return ItemHeights;\n}();\n\nexport { ItemHeights as default };\n//# sourceMappingURL=ItemHeights.js.map","/**\r\n * Same as `lodash`'s `throttle()` for functions with no arguments.\r\n * @param  {function} func\r\n * @param  {number} interval\r\n * @return {function}\r\n */\nexport function throttle(func, interval) {\n  var timeout;\n  var executedAt = 0;\n\n  var scheduled = function scheduled() {\n    timeout = undefined;\n    executedAt = Date.now();\n    func();\n  };\n\n  return function () {\n    var now = Date.now();\n    var remaining = interval - (now - executedAt);\n\n    if (remaining <= 0) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = undefined;\n      }\n\n      executedAt = now;\n      func();\n    } else if (!timeout) {\n      timeout = setTimeout(scheduled, remaining);\n    }\n  };\n}\n/**\r\n * Rounds coordinates upto 4th decimal place (after dot) and appends \"px\".\r\n * Small numbers could be printed as `\"1.2345e-50\"` unless rounded:\r\n * that would be invalid \"px\" value in CSS.\r\n * @param {number}\r\n * @return {string}\r\n */\n\nexport function px(number) {\n  // Fractional pixels are used on \"retina\" screens.\n  return number.toFixed(2) + 'px';\n}\n//# sourceMappingURL=utility.js.map","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport shallowEqual from './shallowEqual';\nimport { getOffset, getScrollY, getScreenHeight, getScreenBounds, clearElement } from './DOM';\nimport ItemHeights from './ItemHeights';\nimport log, { isDebug } from './log';\nimport { throttle } from './utility';\nvar START_FROM_INDEX = 0;\nvar WATCH_CONTAINER_ELEMENT_TOP_COORDINATE_INTERVAL = 500;\nvar WATCH_CONTAINER_ELEMENT_TOP_COORDINATE_MAX_DURATION = 3000;\nvar WINDOW_RESIZE_THROTTLE_DURATION = 200;\n\nvar VirtualScroller =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @param  {function} getContainerNode — Returns container DOM `Element`.\r\n   * @param  {any[]} items — Are only used for getting items count and for comparing \"previous\" items to \"next\" items if `.setItems(newItems)` is called.\r\n   * @param  {Object} [options] — See README.md.\r\n   * @return {VirtualScroller}\r\n   */\n  function VirtualScroller(getContainerNode, items) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, VirtualScroller);\n\n    _defineProperty(this, \"layout\", function () {\n      return _this.onUpdateShownItemIndexes({\n        reason: 'manual'\n      });\n    });\n\n    _defineProperty(this, \"onScroll\", function () {\n      return _this.onUpdateShownItemIndexes({\n        reason: 'scroll'\n      });\n    });\n\n    _defineProperty(this, \"onResize\", throttle(function () {\n      // Reset item heights because now that window width changed\n      // the list width most likely also has changed, and also\n      // some CSS `@media()` rules might have been added or removed.\n      // Re-render the list entirely.\n      _this.setState(_this.getInitialLayoutState(), function () {\n        _this.onInitialRender('resize');\n      });\n    }, WINDOW_RESIZE_THROTTLE_DURATION));\n\n    _defineProperty(this, \"updateShownItemIndexes\", function (callback) {\n      // Find the items which are displayed in the viewport.\n      var _this$getShownItemInd = _this.getShownItemIndexes(),\n          firstShownItemIndex = _this$getShownItemInd.firstShownItemIndex,\n          lastShownItemIndex = _this$getShownItemInd.lastShownItemIndex,\n          redoLayoutAfterRender = _this$getShownItemInd.redoLayoutAfterRender; // Measure \"before\" items height.\n\n\n      var beforeItemsHeight = _this.getBeforeItemsHeight(firstShownItemIndex, lastShownItemIndex); // Measure \"after\" items height.\n\n\n      var afterItemsHeight = _this.getAfterItemsHeight(firstShownItemIndex, lastShownItemIndex); // Update the heights of items to be hidden on next render.\n      // For example, a user could click a \"Show more\" button,\n      // or an \"Expand YouTube video\" button, which would result\n      // in the list item height changing and `this.itemHeights[i]`\n      // being stale, so it's updated here when hiding the item.\n\n\n      _this.updateWillBeHiddenItemHeightsAndState(firstShownItemIndex, lastShownItemIndex); // Debugging.\n\n\n      log('~ Layout results ' + (_this.bypass ? '(bypass) ' : '') + '~');\n      log('First shown item index', firstShownItemIndex);\n      log('Last shown item index', lastShownItemIndex);\n      log('Before items height', beforeItemsHeight);\n      log('After items height', afterItemsHeight);\n      log('Average item height (calculated on previous render)', _this.itemHeights.getAverage());\n\n      if (isDebug()) {\n        log('Item heights', _this.getState().itemHeights.slice());\n        log('Item states', _this.getState().itemStates.slice());\n      }\n\n      if (redoLayoutAfterRender) {\n        log('Redo layout after render');\n      } // Optionally preload items to be rendered.\n\n\n      _this.onShowItems(firstShownItemIndex, lastShownItemIndex); // Render.\n\n\n      _this.setState({\n        firstShownItemIndex: firstShownItemIndex,\n        lastShownItemIndex: lastShownItemIndex,\n        beforeItemsHeight: beforeItemsHeight,\n        afterItemsHeight: afterItemsHeight // // Average item height is stored in state to differentiate between\n        // // the initial state and \"anything has been measured already\" state.\n        // averageItemHeight: this.itemHeights.getAverage()\n\n      }, function () {\n        return callback(redoLayoutAfterRender);\n      });\n    });\n\n    _defineProperty(this, \"updateShownItemIndexesRecursive\", function () {\n      _this.updateShownItemIndexes(function (redoLayoutAfterRender) {\n        if (redoLayoutAfterRender) {\n          // Recurse in a timeout to prevent React error:\n          // \"Maximum update depth exceeded.\n          //  This can happen when a component repeatedly calls\n          //  setState inside componentWillUpdate or componentDidUpdate.\n          //  React limits the number of nested updates to prevent infinite loops.\"\n          setTimeout(function () {\n            if (_this.isMounted) {\n              _this.updateShownItemIndexesRecursive();\n            } else {\n              _this.onDoneUpdatingItemIndexes();\n            }\n          }, 0);\n        } else {\n          _this.onDoneUpdatingItemIndexes();\n        }\n      });\n    });\n\n    _defineProperty(this, \"restoreScroll\", function () {\n      var _this$restoreScrollAf = _this.restoreScrollAfterPrepend,\n          index = _this$restoreScrollAf.index,\n          screenTop = _this$restoreScrollAf.screenTop;\n      _this.restoreScrollAfterPrepend = undefined;\n\n      var newScreenTop = _this.getItemElement(index).getBoundingClientRect().top;\n\n      var scrollByY = newScreenTop - screenTop;\n\n      if (scrollByY !== 0) {\n        log('Restore scroll position: scroll by', scrollByY);\n        window.scrollTo(0, getScrollY() + scrollByY);\n      }\n    });\n\n    _defineProperty(this, \"onUpdateShownItemIndexes\", function (_ref) {\n      var reason = _ref.reason,\n          force = _ref.force;\n\n      // Not implementing the \"delayed\" layout feature for now.\n      // if (this.delayLayout({ reason, force })) {\n      // \treturn\n      // }\n      //\n      // If there're no items then no need to calculate the layout:\n      // if empty `items` have been set on `state` then it has rendered nothing.\n      if (_this.getItemsCount() === 0) {\n        return;\n      } // If a re-layout is already scheduled then it will happen anyway\n      // for the same `state` so there's no need to start another one.\n\n\n      if (_this.isUpdatingItemIndexes) {\n        return;\n      } // Prefer not re-rendering the list as the user's scrolling.\n      // Instead, prefer delaying such re-renders until the user stops scrolling.\n      //\n      // If the user has scrolled then it means that they haven't\n      // stopped scrolling so cancel the timeout.\n      // Otherwise, a layout happens so no need for the deferred one\n      // so cancel the timeout anyway.\n\n\n      clearTimeout(_this.onUserStopsScrollingTimeout); //\n\n      if (reason === 'scroll') {\n        // See whether rendering new previous/next items is required right now\n        // or it can be deferred until the user stops scrolling for better perceived performance.\n        // const listCoordinates = getOffset(this.getContainerNode())\n        // const { top, height } = listCoordinates\n        // const bottom = top + height\n        // const { top: screenTop, bottom: screenBottom } = getScreenBounds()\n        // const renderedItemsTop = top + this.getState().beforeItemsHeight\n        // const renderedItemsBottom = top + height - this.getState().afterItemsHeight\n        // const forceRender = (screenTop < renderedItemsTop && this.getState().firstShownItemIndex > 0) ||\n        // \t(screenBottom > renderedItemsBottom && this.getState().lastShownItemIndex < this.getItemsCount() - 1)\n        var forceRender = // If the items have been rendered at least one\n        _this.latestLayoutScreenTopAfterMargin !== undefined && // If the user has scrolled up past the extra \"margin\"\n        getScrollY() < _this.latestLayoutScreenTopAfterMargin && // and if there're any previous non-rendered items to render.\n        _this.getState().firstShownItemIndex > 0 || // If the items have been rendered at least one\n        _this.latestLayoutScreenBottomAfterMargin !== undefined && // If the user has scrolled down past the extra \"margin\"\n        getScrollY() + getScreenHeight() > _this.latestLayoutScreenBottomAfterMargin && // and if there're any next non-rendered items to render.\n        _this.getState().lastShownItemIndex < _this.getItemsCount() - 1;\n\n        if (forceRender) {\n          log('The user has scrolled far enough: force re-render');\n        } else {\n          log('The user hasn\\'t scrolled too much: delay re-render');\n        } // \"scroll\" events are usually dispatched every 16 milliseconds\n        // for the 60fps refresh rate, so waiting for 100 milliseconds\n        // is about 6 frames of inactivity which would definitely mean\n        // that either the user's no longer scrolling or the browser's\n        // stuttering (skipping frames due to high load) anyway.\n\n\n        if (!forceRender) {\n          return _this.onUserStopsScrollingTimeout = setTimeout(_this.onUserStoppedScrolling, 100);\n        }\n      } // // A minor optimization. Just because I can.\n      // this.listCoordinatesCached = listCoordinates\n      // Re-render the list.\n\n\n      _this.updateLayout(reason);\n    });\n\n    _defineProperty(this, \"onUserStoppedScrolling\", function () {\n      if (_this.isMounted) {\n        // Re-render the list.\n        _this.updateLayout('stopped scrolling');\n      }\n    });\n\n    var getState = options.getState,\n        setState = options.setState,\n        onStateChange = options.onStateChange,\n        preserveScrollPositionAtBottomOnMount = options.preserveScrollPositionAtBottomOnMount,\n        bypass = options.bypass,\n        bypassBatchSize = options.bypassBatchSize;\n    var estimatedItemHeight = options.estimatedItemHeight,\n        onItemFirstRender = options.onItemFirstRender,\n        state = options.state;\n    log('~ Initialize ~'); // If `state` is passed then use `items` from `state`\n    // instead of the `items` argument.\n\n    if (state) {\n      items = state.items;\n    } // if (margin === undefined) {\n    // \t// Renders items which are outside of the screen by this \"margin\".\n    // \t// Is the screen height by default: seems to be the optimal value\n    // \t// for \"Page Up\" / \"Page Down\" navigation and optimized mouse wheel scrolling.\n    // \tmargin = typeof window === 'undefined' ? 0 : window.innerHeight\n    // }\n    // `bypass` mode could work but turns out that\n    // unmounting large React component trees is a\n    // very long process, so it's still not a viable UX.\n\n\n    this.bypass = bypass;\n    this.bypassBatchSize = bypassBatchSize || 10;\n    this.initialItems = items; // this.margin = margin\n\n    this.estimatedItemHeight = estimatedItemHeight; // this.getItemState = getItemState\n\n    if (onItemFirstRender) {\n      this.onItemFirstRender = onItemFirstRender;\n    } // Remove accidental text nodes from container.\n    // Also guards against cases when someone accidentally tries\n    // using `VirtualScroller` on a non-empty element.\n\n\n    if (getContainerNode()) {\n      clearElement(getContainerNode());\n    }\n\n    if (setState) {\n      this.getState = getState;\n      this.setState = setState;\n    } else {\n      this.getState = function () {\n        return _this.state;\n      };\n\n      this.setState = function (state, callback) {\n        var prevState = _this.state;\n        _this.state = _objectSpread({}, prevState, state);\n\n        if (!shallowEqual(_this.state, prevState)) {\n          if (onStateChange) {\n            onStateChange(_this.state, prevState);\n          }\n\n          if (_this.isMounted) {\n            _this.onUpdate(prevState);\n          }\n        }\n\n        if (callback) {\n          callback();\n        }\n      };\n    }\n\n    if (state) {\n      log('Initial state (passed)', state);\n    }\n\n    this.getContainerNode = getContainerNode;\n    this.itemHeights = new ItemHeights(getContainerNode, this.getState);\n\n    if (preserveScrollPositionAtBottomOnMount) {\n      this.preserveScrollPositionAtBottomOnMount = {\n        documentHeight: document.documentElement.scrollHeight\n      };\n    }\n\n    this.setState(state || this.getInitialState(), function () {\n      _this.itemHeights.onInitItemHeights();\n    });\n    log('Items count', items.length); // log('Start from index', START_FROM_INDEX)\n\n    if (estimatedItemHeight) {\n      log('Estimated item height', estimatedItemHeight);\n    }\n  }\n  /**\r\n   * Returns the initial state of the `VirtualScroller`.\r\n   * @param  {object} [customState] — Any additional \"custom\" state may be stored in `VirtualScroller`'s state. For example, React implementation stores item \"refs\" as \"custom\" state.\r\n   * @return {object}\r\n   */\n\n\n  _createClass(VirtualScroller, [{\n    key: \"getInitialState\",\n    value: function getInitialState(customState) {\n      var itemsCount = this.initialItems.length;\n\n      var state = _objectSpread({}, customState, this.getInitialLayoutState(), {\n        items: this.initialItems,\n        itemStates: new Array(itemsCount)\n      });\n\n      log('Initial state (created)', state);\n      log('First shown item index', state.firstShownItemIndex);\n      log('Last shown item index', state.lastShownItemIndex);\n      return state;\n    }\n  }, {\n    key: \"getInitialLayoutState\",\n    value: function getInitialLayoutState() {\n      var firstShownItemIndex;\n      var lastShownItemIndex;\n      var itemsCount = this.initialItems.length; // If there're no items then `firstShownItemIndex` stays `undefined`.\n\n      if (itemsCount > 0) {\n        firstShownItemIndex = Math.min(START_FROM_INDEX, itemsCount - 1);\n        lastShownItemIndex = this.getLastShownItemIndex(firstShownItemIndex, itemsCount);\n      }\n\n      if (this.preserveScrollPositionAtBottomOnMount) {\n        firstShownItemIndex = 0;\n        lastShownItemIndex = itemsCount - 1;\n      } // Optionally preload items to be rendered.\n\n\n      this.onShowItems(firstShownItemIndex, lastShownItemIndex);\n      return {\n        itemHeights: new Array(itemsCount),\n        itemSpacing: undefined,\n        beforeItemsHeight: 0,\n        afterItemsHeight: 0,\n        firstShownItemIndex: firstShownItemIndex,\n        lastShownItemIndex: lastShownItemIndex\n      };\n    }\n    /**\r\n     * Returns estimated list item height.\r\n     * (depends on which items have been previously rendered and measured).\r\n     * @return {number}\r\n     */\n\n  }, {\n    key: \"getEstimatedItemHeight\",\n    value: function getEstimatedItemHeight() {\n      return this.itemHeights && this.itemHeights.getAverage() || this.estimatedItemHeight || 0;\n    }\n  }, {\n    key: \"getItemSpacing\",\n    value: function getItemSpacing() {\n      return this.getState().itemSpacing || 0;\n    }\n  }, {\n    key: \"getEstimatedItemsCount\",\n    value: function getEstimatedItemsCount(height) {\n      if (this.getEstimatedItemHeight()) {\n        return Math.ceil((height + this.getItemSpacing()) / (this.getEstimatedItemHeight() + this.getItemSpacing()));\n      } else {\n        return 1;\n      }\n    }\n  }, {\n    key: \"getEstimatedItemsCountOnScreen\",\n    value: function getEstimatedItemsCountOnScreen() {\n      if (typeof window !== 'undefined') {\n        return this.getEstimatedItemsCount(window.innerHeight);\n      } else {\n        return 1;\n      }\n    }\n  }, {\n    key: \"getLastShownItemIndex\",\n    value: function getLastShownItemIndex(firstShownItemIndex, itemsCount) {\n      return Math.min(firstShownItemIndex + (this.getEstimatedItemsCountOnScreen() - 1), itemsCount - 1);\n    }\n  }, {\n    key: \"getItemsCount\",\n    value: function getItemsCount() {\n      return this.getState().items.length;\n    }\n  }, {\n    key: \"getMargin\",\n    value: function getMargin() {\n      // Renders items which are outside of the screen by this \"margin\".\n      // Is the screen height by default: seems to be the optimal value\n      // for \"Page Up\" / \"Page Down\" navigation and optimized mouse wheel scrolling.\n      return window.innerHeight;\n    }\n  }, {\n    key: \"onShowItems\",\n    value: function onShowItems(firstShownItemIndex, lastShownItemIndex) {\n      if (this.onItemFirstRender) {\n        if (this.firstSeenItemIndex === undefined) {\n          var i = firstShownItemIndex;\n\n          while (i <= lastShownItemIndex) {\n            this.onItemFirstRender(i);\n            i++;\n          }\n        } else {\n          if (firstShownItemIndex < this.firstSeenItemIndex) {\n            var _i = firstShownItemIndex;\n\n            while (_i < this.firstSeenItemIndex) {\n              this.onItemFirstRender(_i);\n              _i++;\n            }\n          }\n\n          if (lastShownItemIndex > this.lastSeenItemIndex) {\n            var _i2 = this.lastSeenItemIndex + 1;\n\n            while (_i2 <= lastShownItemIndex) {\n              this.onItemFirstRender(_i2);\n              _i2++;\n            }\n          }\n        }\n\n        this.firstSeenItemIndex = firstShownItemIndex;\n        this.lastSeenItemIndex = lastShownItemIndex;\n      }\n    }\n  }, {\n    key: \"onMount\",\n    value: function onMount() {\n      this.onInitialRender('mount');\n      this.isMounted = true;\n\n      if (!this.bypass) {\n        window.addEventListener('scroll', this.onScroll);\n        window.addEventListener('resize', this.onResize);\n      }\n    }\n  }, {\n    key: \"onInitialRender\",\n    value: function onInitialRender(reason) {\n      var _this$getState = this.getState(),\n          firstShownItemIndex = _this$getState.firstShownItemIndex,\n          lastShownItemIndex = _this$getState.lastShownItemIndex; // If there're any items.\n\n\n      if (this.getItemsCount() > 0) {\n        // Update item heights.\n        this.updateItemHeights(firstShownItemIndex, lastShownItemIndex);\n      }\n\n      if (this.preserveScrollPositionAtBottomOnMount) {\n        // `window.scrollY` and `window.scrollX` aren't supported in Internet Explorer.\n        window.scrollTo(0, window.pageYOffset + (document.documentElement.scrollHeight - this.preserveScrollPositionAtBottomOnMount.documentHeight));\n      } else {\n        this.onUpdateShownItemIndexes({\n          reason: reason\n        });\n      }\n    }\n  }, {\n    key: \"onUnmount\",\n    value: function onUnmount() {\n      this.isMounted = false;\n\n      if (!this.bypass) {\n        window.removeEventListener('scroll', this.onScroll);\n        window.removeEventListener('resize', this.onResize);\n        clearTimeout(this.onUserStopsScrollingTimeout);\n        clearTimeout(this.watchContainerElementTopCoordinateTimer);\n      }\n    }\n  }, {\n    key: \"onUpdate\",\n    value: function onUpdate(prevState) {\n      var _this$getState2 = this.getState(),\n          items = _this$getState2.items,\n          firstShownItemIndex = _this$getState2.firstShownItemIndex,\n          lastShownItemIndex = _this$getState2.lastShownItemIndex; // If new items are shown (or older items are hidden).\n\n\n      if (firstShownItemIndex !== prevState.firstShownItemIndex || lastShownItemIndex !== prevState.lastShownItemIndex || items !== prevState.items) {\n        // // If some items' height changed then maybe adjust scroll position accordingly.\n        // const prevItemHeights = this.getState().itemHeights.slice()\n        // Update seen item heights.\n        this.updateItemHeights(firstShownItemIndex, lastShownItemIndex); // let i = firstShownItemIndex\n        // while (i <= lastShownItemIndex) {\n        // \tthis.adjustScrollPositionIfNeeded(i, prevItemHeights[i])\n        // \ti++\n        // }\n      }\n    }\n  }, {\n    key: \"updateItemHeights\",\n    value: function updateItemHeights(fromIndex, toIndex) {\n      var _this$getState3 = this.getState(),\n          firstShownItemIndex = _this$getState3.firstShownItemIndex;\n\n      if (fromIndex !== undefined) {\n        log('~ Measure item heights after layout ~');\n        this.itemHeights.update(fromIndex, toIndex, firstShownItemIndex);\n\n        if (isDebug()) {\n          log('Item heights', this.getState().itemHeights.slice());\n        }\n      }\n    }\n  }, {\n    key: \"updateItemHeight\",\n    value: function updateItemHeight(i) {\n      var _this$getState4 = this.getState(),\n          firstShownItemIndex = _this$getState4.firstShownItemIndex;\n\n      this.itemHeights.updateItemHeight(i, firstShownItemIndex);\n    }\n  }, {\n    key: \"onItemStateChange\",\n    value: function onItemStateChange(i, itemState) {\n      if (isDebug()) {\n        log('~ Item state changed ~');\n        log('Item', i);\n        log('Previous state' + '\\n' + JSON.stringify(this.getState().itemStates[i], null, 2));\n        log('New state' + '\\n' + JSON.stringify(itemState, null, 2));\n      }\n\n      this.getState().itemStates[i] = itemState;\n    }\n  }, {\n    key: \"onItemHeightChange\",\n    value: function onItemHeightChange(i) {\n      var _this$getState5 = this.getState(),\n          itemHeights = _this$getState5.itemHeights;\n\n      var previousHeight = itemHeights[i];\n      this.updateItemHeight(i);\n      var newHeight = itemHeights[i];\n\n      if (previousHeight !== newHeight) {\n        log('~ Item height changed ~');\n        log('Item', i);\n        log('Previous height', previousHeight);\n        log('New height', newHeight);\n        this.onUpdateShownItemIndexes({\n          reason: 'item height change'\n        });\n      }\n    }\n    /**\r\n     * Returns coordinates of item with index `i` relative to the document.\r\n     * `top` is the top offset of the item relative to the start of the document.\r\n     * `bottom` is the top offset of the item's bottom edge relative to the start of the document.\r\n     * `height` is the item's height.\r\n     * @param  {number} i\r\n     * @return {object} coordinates — An object of shape `{ top, bottom, height }`.\r\n     */\n\n  }, {\n    key: \"getItemCoordinates\",\n    value: function getItemCoordinates(i) {\n      var _getOffset = getOffset(this.getContainerNode()),\n          top = _getOffset.top;\n\n      var j = 0;\n\n      while (j < i) {\n        top += this.getState().itemHeights[j];\n        top += this.getItemSpacing();\n        j++;\n      }\n\n      return {\n        top: top,\n        bottom: top + this.getState().itemHeights[i],\n        height: this.getState().itemHeights[j]\n      };\n    } // Finds the items which are displayed in the viewport.\n\n  }, {\n    key: \"getVisibleItemIndexes\",\n    value: function getVisibleItemIndexes(screenTop, screenBottom, listTop) {\n      var showItemsFromIndex;\n      var showItemsToIndex;\n      var itemsHeight = 0;\n      var redoLayoutAfterRender = false;\n      var i = START_FROM_INDEX;\n\n      while (i < this.getItemsCount()) {\n        var height = this.itemHeights.get(i); // If an item that hasn't been shown (and measured) yet is encountered\n        // then show such item and then retry after it has been measured.\n\n        if (height === undefined) {\n          log(\"Item \".concat(i, \" height hasn't been measured yet: render and redo layout\"));\n\n          if (showItemsFromIndex === undefined) {\n            showItemsFromIndex = i;\n          }\n\n          var heightLeft = screenBottom - (listTop + itemsHeight);\n          showItemsToIndex = Math.min(i + (this.getEstimatedItemsCount(heightLeft) - 1), // Guard against index overflow.\n          this.getItemsCount() - 1);\n          redoLayoutAfterRender = true;\n          break;\n        }\n\n        itemsHeight += height; // If this is the first item visible\n        // then start showing items from it.\n\n        if (showItemsFromIndex === undefined) {\n          if (listTop + itemsHeight > screenTop) {\n            log('First visible item index (including margin)', i);\n            showItemsFromIndex = i;\n          }\n        } // Items can have spacing.\n\n\n        if (i < this.getItemsCount() - 1) {\n          itemsHeight += this.getItemSpacing();\n        } // If this item is the last one visible in the viewport then exit.\n\n\n        if (listTop + itemsHeight > screenBottom) {\n          log('Last visible item index (including margin)', i); // The list height is estimated until all items have been seen,\n          // so it's possible that even when the list DOM element happens\n          // to be in the viewport in reality the list isn't visible\n          // in which case `showItemsFromIndex` will be `undefined`.\n\n          if (showItemsFromIndex !== undefined) {\n            showItemsToIndex = i;\n          }\n\n          break;\n        }\n\n        i++;\n      } // If there're no more items then the last item is the last one to show.\n\n\n      if (showItemsFromIndex !== undefined && showItemsToIndex === undefined) {\n        showItemsToIndex = this.getItemsCount() - 1;\n        log('Last item index (is fully visible)', showItemsToIndex);\n      } // If scroll position is scheduled to be restored\n      // after render then the anchor item must be rendered\n      // and all the prepended items before it.\n\n\n      if (this.restoreScrollAfterPrepend) {\n        if (showItemsToIndex < this.restoreScrollAfterPrepend.index) {\n          showItemsToIndex = this.restoreScrollAfterPrepend.index;\n        } // `showItemsFromIndex` is always `0` when prepending items.\n        // No need to redo layout after render because all\n        // prepended items are rendered in a single pass.\n        // It removes the visual jitter otherwise happening\n        // due to scroll position restoration waiting for\n        // two layout cycles instead of one.\n\n\n        redoLayoutAfterRender = false;\n      }\n\n      return {\n        firstShownItemIndex: showItemsFromIndex,\n        lastShownItemIndex: showItemsToIndex,\n        redoLayoutAfterRender: redoLayoutAfterRender\n      };\n    }\n  }, {\n    key: \"getOffscreenListShownItemIndexes\",\n    value: function getOffscreenListShownItemIndexes() {\n      var i = START_FROM_INDEX;\n      return {\n        firstShownItemIndex: i,\n        lastShownItemIndex: i,\n        redoLayoutAfterRender: this.itemHeights.get(i) === undefined\n      };\n    }\n  }, {\n    key: \"getItemIndexes\",\n    value: function getItemIndexes(screenTop, screenBottom, top, bottom) {\n      var isVisible = bottom > screenTop && top < screenBottom;\n\n      if (!isVisible) {\n        return this.getOffscreenListShownItemIndexes();\n      } // Find the items which are displayed in the viewport.\n\n\n      var indexes = this.getVisibleItemIndexes(screenTop, screenBottom, top); // The list height is estimated until all items have been seen,\n      // so it's possible that even when the list DOM element happens\n      // to be in the viewport in reality the list isn't visible\n      // in which case `firstShownItemIndex` will be `undefined`.\n\n      if (indexes.firstShownItemIndex === undefined) {\n        return this.getOffscreenListShownItemIndexes();\n      }\n\n      return indexes;\n    }\n    /**\r\n     * Measures \"before\" items height.\r\n     * @param  {number} firstShownItemIndex — New first shown item index.\r\n     * @param  {number} lastShownItemIndex — New last shown item index.\r\n     * @return {number}\r\n     */\n\n  }, {\n    key: \"getBeforeItemsHeight\",\n    value: function getBeforeItemsHeight(firstShownItemIndex, lastShownItemIndex) {\n      var beforeItemsHeight = 0; // Add all \"before\" items height.\n\n      var i = START_FROM_INDEX;\n\n      while (i < firstShownItemIndex) {\n        beforeItemsHeight += this.itemHeights.get(i) || this.itemHeights.getAverage();\n        beforeItemsHeight += this.getItemSpacing();\n        i++;\n      }\n\n      return beforeItemsHeight;\n    }\n    /**\r\n     * Measures \"after\" items height.\r\n     * @param  {number} firstShownItemIndex — New first shown item index.\r\n     * @param  {number} lastShownItemIndex — New last shown item index.\r\n     * @return {number}\r\n     */\n\n  }, {\n    key: \"getAfterItemsHeight\",\n    value: function getAfterItemsHeight(firstShownItemIndex, lastShownItemIndex) {\n      var afterItemsHeight = 0;\n      var i = lastShownItemIndex + 1; // Add all \"after\" items height.\n\n      while (i < this.getItemsCount()) {\n        afterItemsHeight += this.getItemSpacing();\n        afterItemsHeight += this.itemHeights.get(i) || this.itemHeights.getAverage();\n        i++;\n      }\n\n      return afterItemsHeight;\n    }\n    /**\r\n     * Updates the heights of items to be hidden on next render.\r\n     * For example, a user could click a \"Show more\" button,\r\n     * or an \"Expand YouTube video\" button, which would result\r\n     * in the list item height changing and `this.itemHeights[i]`\r\n     * being stale, so it's updated here when hiding the item.\r\n     */\n\n  }, {\n    key: \"updateWillBeHiddenItemHeightsAndState\",\n    value: function updateWillBeHiddenItemHeightsAndState(firstShownItemIndex, lastShownItemIndex) {\n      var i = this.getState().firstShownItemIndex;\n\n      while (i <= this.getState().lastShownItemIndex) {\n        if (i >= firstShownItemIndex && i <= lastShownItemIndex) {// The item's still visible.\n        } else {\n          // Update item's height before hiding it\n          // because the height of the item may have changed\n          // while it was visible.\n          this.updateItemHeight(i); // // Update item's state because it's about to be hidden.\n          // if (this.getItemState) {\n          // \tthis.getState().itemStates[i] = this.getItemState(\n          // \t\tthis.getState().items[i],\n          // \t\ti,\n          // \t\tthis.getState().items\n          // \t)\n          // }\n        }\n\n        i++;\n      }\n    } // `VirtualScroller` calls `getShownItemIndexes()` on mount\n    // but if the page styles are applied after `VirtualScroller` mounts\n    // (for example, if styles are applied via javascript, like Webpack does)\n    // then the list might not render correctly and will only show the first item.\n    // The reason for that would be that calling `.getBoundingClientRect()`\n    // on the list container element on mount returned \"incorrect\" `top` position\n    // because the styles haven't been applied yet.\n    // For example, consider a page:\n    // <div class=\"page\">\n    //   <nav class=\"sidebar\">...</nav>\n    //   <main>...</main>\n    // </div>\n    // The sidebar is styled as `position: fixed`, but until\n    // the page styles have been applied it's gonna be a regular `<div/>`\n    // meaning that `<main/>` will be rendered below the sidebar\n    // and will appear offscreen and so it will only render the first item.\n    // Then, the page styles are loaded and applied and the sidebar\n    // is now `position: fixed` so `<main/>` is now rendered at the top of the page\n    // but `VirtualScroller`'s `onMount()` has already been called\n    // and it won't re-render until the user scrolls or the window is resized.\n    // This type of a bug doesn't occur in production, but it can appear\n    // in development mode when using Webpack. The workaround `VirtualScroller`\n    // implements for such cases is calling `.getBoundingClientRect()` on the\n    // list container DOM element periodically (every second) to check if the\n    // `top` coordinate has changed as a result of CSS being applied:\n    // if it has then it recalculates the shown item indexes.\n\n  }, {\n    key: \"watchContainerElementTopCoordinate\",\n    value: function watchContainerElementTopCoordinate() {\n      var _this2 = this;\n\n      var startedAt = Date.now();\n\n      var check = function check() {\n        // Skip comparing `top` coordinate of the list\n        // when this function is called the first time.\n        if (_this2.top !== undefined) {\n          // Calling `getOffset()` on an element is about\n          // 0.003 milliseconds on a modern desktop CPU,\n          // so I guess it's fine calling it twice a second.\n          var _getOffset2 = getOffset(_this2.getContainerNode()),\n              top = _getOffset2.top;\n\n          if (top !== _this2.top) {\n            _this2.onUpdateShownItemIndexes({\n              reason: 'top offset change'\n            });\n          }\n        } // Compare `top` coordinate of the list twice a second\n        // to find out if it has changed as a result of loading CSS styles.\n        // The total duration of 3 seconds would be enough for any styles to load, I guess.\n        // There could be other cases changing the `top` coordinate\n        // of the list (like collapsing an \"accordeon\" panel above the list\n        // without scrolling the page), but those cases should be handled\n        // by manually calling `.layout()` instance method on `VirtualScroller` instance.\n\n\n        if (Date.now() - startedAt < WATCH_CONTAINER_ELEMENT_TOP_COORDINATE_MAX_DURATION) {\n          _this2.watchContainerElementTopCoordinateTimer = setTimeout(check, WATCH_CONTAINER_ELEMENT_TOP_COORDINATE_INTERVAL);\n        }\n      }; // Run the cycle.\n\n\n      check();\n    }\n    /**\r\n     * Finds the items that are displayed in the viewport.\r\n     * @return {object} `{ firstShownItemIndex: number, lastShownItemIndex: number, redoLayoutAfterRender: boolean }`\r\n     */\n\n  }, {\n    key: \"getShownItemIndexes\",\n    value: function getShownItemIndexes() {\n      if (this.bypass) {\n        var _this$getState6 = this.getState(),\n            firstShownItemIndex = _this$getState6.firstShownItemIndex;\n\n        var _this$getState7 = this.getState(),\n            lastShownItemIndex = _this$getState7.lastShownItemIndex;\n\n        lastShownItemIndex = Math.min(lastShownItemIndex + this.bypassBatchSize, this.getItemsCount() - 1);\n        return {\n          firstShownItemIndex: firstShownItemIndex,\n          lastShownItemIndex: lastShownItemIndex,\n          // Redo layout untill all items are rendered.\n          redoLayoutAfterRender: lastShownItemIndex < this.getItemsCount() - 1\n        };\n      } // // A minor optimization. Just because I can.\n      // let listCoordinates\n      // if (this.listCoordinatesCached) {\n      // \tlistCoordinates = this.listCoordinatesCached\n      // \tthis.listCoordinatesCached = undefined\n      // } else {\n      // \tlistCoordinates = getOffset(this.getContainerNode())\n      // }\n      // const { top, height } = listCoordinates\n\n\n      var _getOffset3 = getOffset(this.getContainerNode()),\n          top = _getOffset3.top,\n          height = _getOffset3.height; // `this.top` is not used for any \"caching\",\n      // it's only used in `this.watchContainerElementTopCoordinate()` method.\n\n\n      if (this.top === undefined) {\n        // See the comments for `watchContainerElementTopCoordinate()` method\n        // for the rationale on why it's here.\n        this.watchContainerElementTopCoordinate();\n      }\n\n      this.top = top;\n\n      var _getScreenBounds = getScreenBounds(),\n          screenTop = _getScreenBounds.top,\n          screenBottom = _getScreenBounds.bottom; // Set screen top and bottom for current layout.\n\n\n      this.latestLayoutScreenTopAfterMargin = screenTop - this.getMargin();\n      this.latestLayoutScreenBottomAfterMargin = screenBottom + this.getMargin(); // Find the items that are displayed in the viewport.\n\n      return this.getItemIndexes(screenTop - this.getMargin(), screenBottom + this.getMargin(), top, top + height);\n    }\n    /**\r\n     * Updates the \"from\" and \"to\" shown item indexes.\r\n     * `callback(redoLayoutAfterRender)` is called after it re-renders.\r\n     * If the list is visible and some of the items being shown are new\r\n     * and required to be measured first then `redoLayoutAfterRender` is `true`.\r\n     * If the list is visible and all items being shown have been encountered\r\n     * (and measured) before then `redoLayoutAfterRender` is `false`.\r\n     * @param {Function} callback\r\n     */\n\n  }, {\n    key: \"onDoneUpdatingItemIndexes\",\n    value: function onDoneUpdatingItemIndexes() {\n      this.isUpdatingItemIndexes = false;\n\n      if (this.restoreScrollAfterPrepend) {\n        this.restoreScroll();\n      }\n    }\n  }, {\n    key: \"captureScroll\",\n    value: function captureScroll(previousItems, nextItems, firstPreviousItemIndex) {\n      // If there were no items in the list\n      // then there's no point in restoring scroll position.\n      if (previousItems.length === 0) {\n        return;\n      }\n\n      if (firstPreviousItemIndex === undefined) {\n        firstPreviousItemIndex = nextItems.indexOf(previousItems[0]);\n      } // If the items update wasn't incremental\n      // then there's no point in restoring scroll position.\n\n\n      if (firstPreviousItemIndex < 0) {\n        return;\n      } // If no items were prepended then no need to restore scroll position.\n\n\n      if (firstPreviousItemIndex === 0) {\n        return;\n      } // The first item DOM Element must be rendered in order to get its top position.\n\n\n      if (this.getState().firstShownItemIndex > 0) {\n        return;\n      } // If the scroll position for these `previousItems` -> `nextItems`\n      // has already been captured then skip.\n      // This could happen when using `<ReactVirtualScroller/>`\n      // because it calls `.captureScroll()` inside `.render()`\n      // which is followed by `<VirtualScroller/>`'s `.componentDidUpdate()`\n      // which also calls `.captureScroll()` with the same arguments.\n      // (this is done to prevent scroll Y position from jumping\n      //  when showing the first page of the \"Previous items\",\n      //  see the comments in `<ReactVirtualScroller/>`'s `.render()` method).\n\n\n      if (this.restoreScrollAfterPrepend && this.restoreScrollAfterPrepend.previousItems === previousItems && this.restoreScrollAfterPrepend.nextItems === nextItems) {\n        return;\n      }\n\n      this.restoreScrollAfterPrepend = {\n        previousItems: previousItems,\n        nextItems: nextItems,\n        index: firstPreviousItemIndex,\n        screenTop: this.getItemElement(0).getBoundingClientRect().top\n      };\n    }\n  }, {\n    key: \"updateLayout\",\n    value: function updateLayout(reason) {\n      log(\"~ Update layout (\".concat(reason, \") ~\"));\n      this.isUpdatingItemIndexes = true;\n      this.updateShownItemIndexesRecursive();\n    }\n  }, {\n    key: \"updateItems\",\n\n    /**\r\n     * @deprecated\r\n     * `.updateItems()` has been renamed to `.setItems()`.\r\n     */\n    value: function updateItems(newItems, options) {\n      return this.setItems(newItems, options);\n    }\n    /**\r\n     * Updates `items`. For example, can prepend or append new items to the list.\r\n     * @param  {any[]} newItems\r\n     * @param {boolean} [options.preserveScrollPositionOnPrependItems] — Set to `true` to enable \"restore scroll position after prepending items\" feature (could be useful when implementing \"Show previous items\" button).\r\n     */\n\n  }, {\n    key: \"setItems\",\n    value: function setItems(newItems) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      // * @param  {object} [newCustomState] — If `customState` was passed to `getInitialState()`, this `newCustomState` updates it.\n      var _this$getState8 = this.getState(),\n          previousItems = _this$getState8.items;\n\n      var _this$getState9 = this.getState(),\n          firstShownItemIndex = _this$getState9.firstShownItemIndex,\n          lastShownItemIndex = _this$getState9.lastShownItemIndex,\n          beforeItemsHeight = _this$getState9.beforeItemsHeight,\n          afterItemsHeight = _this$getState9.afterItemsHeight,\n          itemStates = _this$getState9.itemStates,\n          itemHeights = _this$getState9.itemHeights,\n          itemSpacing = _this$getState9.itemSpacing;\n\n      log('~ Update items ~');\n\n      var _getItemsDiff = getItemsDiff(previousItems, newItems),\n          prependedItemsCount = _getItemsDiff.prependedItemsCount,\n          appendedItemsCount = _getItemsDiff.appendedItemsCount;\n\n      var isIncrementalUpdate = prependedItemsCount > 0 || appendedItemsCount > 0;\n\n      if (isIncrementalUpdate) {\n        if (prependedItemsCount > 0) {\n          log('Prepended items count', prependedItemsCount);\n\n          if (this.firstSeenItemIndex !== undefined) {\n            this.firstSeenItemIndex += prependedItemsCount;\n          }\n\n          itemHeights = new Array(prependedItemsCount).concat(itemHeights);\n          this.itemHeights.onPrepend(prependedItemsCount);\n\n          if (itemStates) {\n            itemStates = new Array(prependedItemsCount).concat(itemStates);\n          } // Since some items were prepended restore scroll Y\n          // position after rendering those new items.\n          // `preserveScrollPosition` property name is deprecated,\n          // use `preserveScrollPositionOnPrependItems` instead.\n\n\n          if (options.preserveScrollPositionOnPrependItems || options.preserveScrollPosition) {\n            this.captureScroll(previousItems, newItems, prependedItemsCount);\n          }\n        }\n\n        if (appendedItemsCount > 0) {\n          log('Appended items count', appendedItemsCount);\n          itemHeights = itemHeights.concat(new Array(appendedItemsCount));\n\n          if (itemStates) {\n            itemStates = itemStates.concat(new Array(appendedItemsCount));\n          }\n        }\n\n        firstShownItemIndex += prependedItemsCount;\n        lastShownItemIndex += prependedItemsCount;\n        beforeItemsHeight += this.itemHeights.getAverage() * prependedItemsCount;\n        afterItemsHeight += this.itemHeights.getAverage() * appendedItemsCount;\n      } else {\n        log('Non-incremental items update');\n        log('Previous items', previousItems);\n        log('New items', newItems);\n        itemHeights = new Array(newItems.length);\n        itemStates = new Array(newItems.length);\n\n        if (newItems.length === 0) {\n          firstShownItemIndex = undefined;\n          lastShownItemIndex = undefined;\n        } else {\n          firstShownItemIndex = 0;\n          lastShownItemIndex = this.getLastShownItemIndex(firstShownItemIndex, newItems.length);\n        }\n\n        beforeItemsHeight = 0;\n        afterItemsHeight = 0;\n      }\n\n      var customState; // `newCustomState` argument is not currently being used.\n      // if (newCustomState) {\n      // \tif (typeof newCustomState === 'function') {\n      // \t\tcustomState = newCustomState(this.getState(), {\n      // \t\t\tprependedCount: isIncrementalUpdate ? undefined : prependedItemsCount,\n      // \t\t\tappendedCount: isIncrementalUpdate ? undefined : appendedItemsCount\n      // \t\t})\n      // \t} else {\n      // \t\tcustomState = newCustomState\n      // \t}\n      // }\n\n      log('First shown item index', firstShownItemIndex);\n      log('Last shown item index', lastShownItemIndex);\n      log('Before items height', beforeItemsHeight);\n      log('After items height', afterItemsHeight); // Optionally preload items to be rendered.\n\n      this.onShowItems(firstShownItemIndex, lastShownItemIndex); // Render.\n\n      this.setState(_objectSpread({}, customState, {\n        items: newItems,\n        itemStates: itemStates,\n        itemHeights: itemHeights,\n        firstShownItemIndex: firstShownItemIndex,\n        lastShownItemIndex: lastShownItemIndex,\n        beforeItemsHeight: beforeItemsHeight,\n        afterItemsHeight: afterItemsHeight\n      }), function () {\n        if (!isIncrementalUpdate) {\n          _this3.firstSeenItemIndex = undefined;\n          _this3.lastSeenItemIndex = undefined;\n\n          _this3.itemHeights.onInitItemHeights();\n        }\n\n        _this3.onUpdateShownItemIndexes({\n          reason: 'update items',\n          force: true\n        });\n      });\n    }\n  }, {\n    key: \"getItemElement\",\n    value: function getItemElement(i) {\n      return this.getContainerNode().childNodes[i];\n    } // Turns out this optimization won't work\n    // because sometimes item height is an average approximation\n    // and the other times it's the real item height\n    // and sometimes it can change while item's not visible.\n    // /**\n    //  * Measures new \"before\" items height.\n    //  * @param  {number} firstShownItemIndex — New first shown item index.\n    //  * @param  {number} lastShownItemIndex — New last shown item index.\n    //  * @return {number}\n    //  */\n    // getBeforeItemsHeightOptimized(firstShownItemIndex, lastShownItemIndex) {\n    // \t// If the previous and new shown item indexes intersect\n    // \t// then the new \"before\" items height may be calculated\n    // \t// based on the previous \"before\" items height.\n    // \tif (this.getState().averageItemHeight !== undefined &&\n    // \t\tthis.doPrevAndNextItemIndexesIntersect(firstShownItemIndex, lastShownItemIndex)) {\n    // \t\tlet beforeItemsHeight = this.getState().beforeItemsHeight\n    // \t\t// Add all \"before\" will-be-hidden items' height.\n    // \t\tlet i = this.getState().firstShownItemIndex\n    // \t\twhile (i <= this.getState().lastShownItemIndex && i < firstShownItemIndex) {\n    // \t\t\tbeforeItemsHeight += (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tbeforeItemsHeight += this.getItemSpacing()\n    // \t\t\ti++\n    // \t\t}\n    // \t\t// Subtract all \"before\" will-be-shown items' height.\n    // \t\ti = firstShownItemIndex\n    // \t\twhile (i <= lastShownItemIndex && i < this.getState().firstShownItemIndex) {\n    // \t\t\tbeforeItemsHeight -= (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tbeforeItemsHeight -= this.getItemSpacing()\n    // \t\t\ti++\n    // \t\t}\n    // \t\treturn beforeItemsHeight\n    // \t}\n    // \t// If the previous and new shown item indexes don't intersect\n    // \t// then re-calculate \"before\" items height.\n    // \telse {\n    // \t\treturn this.getBeforeItemsHeight(firstShownItemIndex, lastShownItemIndex)\n    // \t}\n    // }\n    // Turns out this optimization won't work\n    // because sometimes item height is an average approximation\n    // and the other times it's the real item height\n    // and sometimes it can change while item's not visible.\n    // /**\n    //  * Measures new \"after\" items height.\n    //  * @param  {number} firstShownItemIndex — New first shown item index.\n    //  * @param  {number} lastShownItemIndex — New last shown item index.\n    //  * @return {number}\n    //  */\n    // getAfterItemsHeightOptimized(firstShownItemIndex, lastShownItemIndex) {\n    // \t// If the previous and new shown item indexes intersect\n    // \t// then the new \"after\" items height may be calculated\n    // \t// based on the previous \"after\" items height.\n    // \tif (this.getState().averageItemHeight !== undefined &&\n    // \t\tthis.doPrevAndNextItemIndexesIntersect(firstShownItemIndex, lastShownItemIndex)) {\n    // \t\tlet afterItemsHeight = this.getState().afterItemsHeight\n    // \t\t// Add all \"after\" will-be-hidden items' height.\n    // \t\tlet i = this.getState().lastShownItemIndex\n    // \t\twhile (i >= this.getState().firstShownItemIndex && i > lastShownItemIndex) {\n    // \t\t\tafterItemsHeight += (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tafterItemsHeight += this.getItemSpacing()\n    // \t\t\ti--\n    // \t\t}\n    // \t\t// Subtract all \"after\" will-be-shown items' height.\n    // \t\ti = lastShownItemIndex\n    // \t\twhile (i >= firstShownItemIndex && i > this.getState().lastShownItemIndex) {\n    // \t\t\tafterItemsHeight -= (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tafterItemsHeight -= this.getItemSpacing()\n    // \t\t\ti--\n    // \t\t}\n    // \t\treturn afterItemsHeight\n    // \t}\n    // \t// If the previous and new shown item indexes don't intersect\n    // \t// then re-calculate \"after\" items height.\n    // \telse {\n    // \t\treturn this.getAfterItemsHeight(firstShownItemIndex, lastShownItemIndex)\n    // \t}\n    // }\n    // Was used it `.getBeforeItemsHeightOptimized()` and `.getAfterItemsHeightOptimized()`.\n    // doPrevAndNextItemIndexesIntersect(firstShownItemIndex, lastShownItemIndex) {\n    // \treturn firstShownItemIndex <= this.getState().lastShownItemIndex &&\n    // \t\tlastShownItemIndex >= this.getState().firstShownItemIndex\n    // }\n    // Not implementing the \"delayed\" layout feature for now.\n    // delayLayout(args) {\n    // \t// Suppose there's a \"router\" library which restores scroll position\n    // \t// on \"Back\" navigation but only does so after `componentDidMount()`\n    // \t// is called on the underlying page meaning that by the time\n    // \t// the scroll position is restored the `VirtualScroller` component\n    // \t// has already rendered with previous page's scroll position\n    // \t// resulting in an unnecessary layout. \"Delaying\" layout\n    // \t// means that the layout is called in a `setTimeout(..., 0)` call\n    // \t// rather than immediately on mount.\n    // \tif (this.shouldDelayLayout) {\n    // \t\tthis.layoutDelayedWithArgs = args\n    // \t\t// Then in `.onMount()`:\n    // \t\t// if (this.layoutDelayedWithArgs) {\n    // \t\t// \tthis.shouldDelayLayout = false\n    // \t\t// \tsetTimeout(() => {\n    // \t\t// \t\tif (this.isMounted) {\n    // \t\t// \t\t\tthis.onUpdateShownItemIndexes(this.layoutDelayedWithArgs)\n    // \t\t// \t\t\tthis.layoutDelayedWithArgs = undefined\n    // \t\t// \t\t}\n    // \t\t// \t}, 0)\n    // \t\t// }\n    // \t\treturn true\n    // \t}\n    // }\n\n  }]);\n\n  return VirtualScroller;\n}();\n\nexport { VirtualScroller as default };\n\nfunction getRemainderRest(n, divider) {\n  var remainder = n % divider;\n\n  if (remainder > 0) {\n    return divider - remainder;\n  }\n\n  return 0;\n}\n\nexport function getItemsDiff(previousItems, newItems) {\n  var firstPreviousItemIndex = -1;\n  var lastPreviousItemIndex = -1;\n\n  if (previousItems.length > 0) {\n    firstPreviousItemIndex = newItems.indexOf(previousItems[0]);\n\n    if (firstPreviousItemIndex >= 0) {\n      if (arePreviousItemsPreserved(previousItems, newItems, firstPreviousItemIndex)) {\n        lastPreviousItemIndex = firstPreviousItemIndex + previousItems.length - 1;\n      }\n    }\n  }\n\n  var isIncrementalUpdate = firstPreviousItemIndex >= 0 && lastPreviousItemIndex >= 0;\n\n  if (isIncrementalUpdate) {\n    return {\n      prependedItemsCount: firstPreviousItemIndex,\n      appendedItemsCount: newItems.length - (lastPreviousItemIndex + 1)\n    };\n  }\n\n  return {\n    prependedItemsCount: -1,\n    appendedItemsCount: -1\n  };\n}\n\nfunction arePreviousItemsPreserved(previousItems, newItems, offset) {\n  // Check each item of the `previousItems` to determine\n  // whether it's an \"incremental\" items update.\n  // (an update when items are prepended or appended)\n  var i = 0;\n\n  while (i < previousItems.length) {\n    if (newItems.length <= offset + i || newItems[offset + i] !== previousItems[i]) {\n      return false;\n    }\n\n    i++;\n  }\n\n  return true;\n}\n//# sourceMappingURL=VirtualScroller.js.map","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport VirtualScroller, { getItemsDiff } from './VirtualScroller';\nimport shallowEqual from './shallowEqual';\nimport { px } from './utility'; // `PropTypes.elementType` is available in some version of `prop-types`.\n// https://github.com/facebook/prop-types/issues/200\n\nvar elementType = PropTypes.elementType || PropTypes.oneOfType([PropTypes.func, PropTypes.object]);\n\nvar ReactVirtualScroller =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(ReactVirtualScroller, _React$Component);\n\n  // Handler function caches.\n  // Just so that the props passed to `itemComponent`\n  // are not changed on every `.render()` and so\n  // `itemComponent` won't re-render if it's a `PureComponent`.\n  // Item refs for `.renderItem(i)`.\n  // List items are rendered with `key`s\n  // so that React doesn't reuse `itemComponent`s\n  // in cases when `items` are changed.\n  function ReactVirtualScroller(props) {\n    var _this;\n\n    _classCallCheck(this, ReactVirtualScroller);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactVirtualScroller).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"container\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"onItemStateChange\", new Array(_this.props.items.length));\n\n    _defineProperty(_assertThisInitialized(_this), \"onItemHeightChange\", new Array(_this.props.items.length));\n\n    _defineProperty(_assertThisInitialized(_this), \"itemRefs\", new Array(_this.props.items.length));\n\n    _defineProperty(_assertThisInitialized(_this), \"uniquePrefixes\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"layout\", function () {\n      return _this.virtualScroller.layout();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onItemFirstRender\", function () {\n      var onItemFirstRender = _this.props.onItemFirstRender;\n\n      if (onItemFirstRender) {\n        onItemFirstRender.apply(void 0, arguments);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onStateChange\", function () {\n      var onStateChange = _this.props.onStateChange;\n\n      if (onStateChange) {\n        onStateChange.apply(void 0, arguments);\n      }\n    });\n\n    var _this$props = _this.props,\n        items = _this$props.items,\n        initialState = _this$props.initialState,\n        estimatedItemHeight = _this$props.estimatedItemHeight,\n        preserveScrollPositionAtBottomOnMount = _this$props.preserveScrollPositionAtBottomOnMount,\n        bypass = _this$props.bypass,\n        bypassBatchSize = _this$props.bypassBatchSize; // `this.previousItemsProperty` is only used for comparing\n    // `previousItems` with `newItems` in `render()`.\n\n    _this.previousItemsProperty = items; // Create `virtual-scroller` instance.\n\n    _this.virtualScroller = new VirtualScroller(function () {\n      return _this.container.current;\n    }, items, {\n      estimatedItemHeight: estimatedItemHeight,\n      bypass: bypass,\n      bypassBatchSize: bypassBatchSize,\n      onItemFirstRender: _this.onItemFirstRender,\n      preserveScrollPositionAtBottomOnMount: preserveScrollPositionAtBottomOnMount,\n      state: initialState,\n      getState: function getState() {\n        return _this.state;\n      },\n      setState: function setState(newState, callback) {\n        if (_this.state) {\n          // Update existing state.\n          _this.setState(newState, callback);\n        } else {\n          // Set initial state.\n          _this.state = newState;\n\n          _this.onStateChange(newState);\n        }\n      }\n    }); // Generate unique `key` prefix for list item components.\n\n    _this.generateUniquePrefix();\n\n    return _this;\n  } // This is a proxy for `VirtualScroller`'s `.layout` instance method.\n\n\n  _createClass(ReactVirtualScroller, [{\n    key: \"shouldUseRefs\",\n    value: function shouldUseRefs() {\n      // There's no way to detect if `ref` can be passed to `component`:\n      // https://github.com/facebook/react/issues/16309\n      // So only uses `ref`s for `React.Component`s.\n      var itemComponent = this.props.itemComponent;\n      return isComponentClass(itemComponent);\n    }\n    /**\r\n     * A proxy to `VirtualScroller.getItemCoordinates(i)`.\r\n     * @param  {number} i\r\n     * @return {object}\r\n     */\n\n  }, {\n    key: \"getItemCoordinates\",\n    value: function getItemCoordinates(i) {\n      return this.virtualScroller.getItemCoordinates(i);\n    }\n    /**\r\n     * `updateItem(i)` has been renamed to `renderItem(i)`.\r\n     * @param {number} i\r\n     */\n\n  }, {\n    key: \"updateItem\",\n    value: function updateItem(i) {\n      return this.renderItem(i);\n    }\n    /**\r\n     * Re-renders an item.\r\n     * @param {number} i\r\n     */\n\n  }, {\n    key: \"renderItem\",\n    value: function renderItem(i) {\n      var _this2 = this;\n\n      if (!this.shouldUseRefs()) {\n        return console.error('[virtual-scroller] `.renderItem(i)` has been called but the `component` doesn\\'t allow `ref`s. Only `component`s that\\'re `React.Component`s support this feature.');\n      } // The item may be non-rendered when `.renderItem(i)` is called on it.\n      // For example, when there's a \"parent comment\" having several \"replies\"\n      // each of which has an autogenerated quote of the \"parent comment\"\n      // and then the \"parent comment\" is updated (for example, a YouTube video\n      // link gets parsed into an embedded video player) and all of its \"replies\"\n      // should be updated too to show the parsed video title instead of the URL,\n      // so `.renderItem(i)` is simply called on all of the \"parent post\"'s replies\n      // regardless of some of those replies being rendered or not.\n\n\n      if (this.itemRefs[i] && this.itemRefs[i].current) {\n        var items = this.props.items; // Stores `item` here because the `i` index\n        // might have changed when the callback is called,\n        // or the item even may have been removed.\n\n        var item = items[i];\n        this.itemRefs[i].current.forceUpdate(function () {\n          if (_this2._isMounted) {\n            // Recalculates the `i` index here because it\n            // might have changed when the callback is called,\n            // or the item even may have been removed.\n            var _i = items.indexOf(item);\n\n            if (_i >= 0) {\n              _this2.virtualScroller.onItemHeightChange(_i);\n            }\n          }\n        });\n      }\n    } // Functional components can't have a `ref` assigned to them.\n    // Item `ref`s are only used for calling `.renderItem(i)` instance method.\n    // If a developer is not using the `.renderItem(i)` instance method\n    // then `ref`s aren't required and will be omitted.\n\n  }, {\n    key: \"getItemRef\",\n    value: function getItemRef(i) {\n      if (!this.itemRefs[i]) {\n        this.itemRefs[i] = React.createRef();\n      }\n\n      return this.itemRefs[i];\n    }\n  }, {\n    key: \"getOnItemStateChange\",\n    value: function getOnItemStateChange(i) {\n      var _this3 = this;\n\n      if (!this.onItemStateChange[i]) {\n        this.onItemStateChange[i] = function (itemState) {\n          return _this3.virtualScroller.onItemStateChange(i, itemState);\n        };\n      }\n\n      return this.onItemStateChange[i];\n    }\n  }, {\n    key: \"getOnItemHeightChange\",\n    value: function getOnItemHeightChange(i) {\n      var _this4 = this;\n\n      if (!this.onItemHeightChange[i]) {\n        this.onItemHeightChange[i] = function () {\n          return _this4.virtualScroller.onItemHeightChange(i);\n        };\n      }\n\n      return this.onItemHeightChange[i];\n    }\n  }, {\n    key: \"generateUniquePrefix\",\n    value: function generateUniquePrefix() {\n      var prefix = String(Math.random()).slice(2);\n\n      if (this.uniquePrefixes.indexOf(prefix) >= 0) {\n        return this.generateUniquePrefix();\n      }\n\n      this.uniquePrefixes.push(prefix);\n      this.uniquePrefix = prefix;\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var onMount = this.props.onMount; // `onMount()` should be called before `VirtualScroller`'s\n      // in order for it to be able to be used for restoring\n      // page scroll Y position.\n\n      if (onMount) {\n        onMount();\n      }\n\n      this.virtualScroller.onMount();\n      this._isMounted = true;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var onStateChange = this.props.onStateChange; // An application may choose to track `virtual-scroller` state\n      // for restoring it later on \"Back\" navigation.\n\n      if (onStateChange) {\n        if (!shallowEqual(this.state, prevState)) {\n          onStateChange(this.state, prevState);\n        }\n      } // Re-measure rendered items' heights.\n\n\n      this.virtualScroller.onUpdate(prevState); // If `items` property did change then update `virtual-scroller` items.\n      // This could have been done in `.render()` but `.setItems()` calls\n      // `.setState()` internally which would result in React throwing an error.\n\n      var _this$props2 = this.props,\n          items = _this$props2.items,\n          preserveScrollPosition = _this$props2.preserveScrollPosition,\n          preserveScrollPositionOnPrependItems = _this$props2.preserveScrollPositionOnPrependItems;\n\n      if (items !== prevProps.items) {\n        this.virtualScroller.setItems(items, {\n          // `preserveScrollPosition` property name is deprecated,\n          // use `preserveScrollPositionOnPrependItems` instead.\n          preserveScrollPositionOnPrependItems: preserveScrollPositionOnPrependItems || preserveScrollPosition\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.virtualScroller.onUnmount();\n      this._isMounted = false;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var _this$props3 = this.props,\n          Component = _this$props3.itemComponent,\n          itemComponentProps = _this$props3.itemComponentProps,\n          _items = _this$props3.items,\n          estimatedItemHeight = _this$props3.estimatedItemHeight,\n          bypass = _this$props3.bypass,\n          bypassBatchSize = _this$props3.bypassBatchSize,\n          preserveScrollPositionOnPrependItems = _this$props3.preserveScrollPositionOnPrependItems,\n          preserveScrollPosition = _this$props3.preserveScrollPosition,\n          preserveScrollPositionAtBottomOnMount = _this$props3.preserveScrollPositionAtBottomOnMount,\n          initialState = _this$props3.initialState,\n          onStateChange = _this$props3.onStateChange,\n          onItemFirstRender = _this$props3.onItemFirstRender,\n          onMount = _this$props3.onMount,\n          rest = _objectWithoutProperties(_this$props3, [\"itemComponent\", \"itemComponentProps\", \"items\", \"estimatedItemHeight\", \"bypass\", \"bypassBatchSize\", \"preserveScrollPositionOnPrependItems\", \"preserveScrollPosition\", \"preserveScrollPositionAtBottomOnMount\", \"initialState\", \"onStateChange\", \"onItemFirstRender\", \"onMount\"]);\n\n      var _this$virtualScroller = this.virtualScroller.getState(),\n          items = _this$virtualScroller.items,\n          itemStates = _this$virtualScroller.itemStates,\n          firstShownItemIndex = _this$virtualScroller.firstShownItemIndex,\n          lastShownItemIndex = _this$virtualScroller.lastShownItemIndex,\n          beforeItemsHeight = _this$virtualScroller.beforeItemsHeight,\n          afterItemsHeight = _this$virtualScroller.afterItemsHeight; // If `items` are about to be changed then\n      // store the scroll Y position for the first one\n      // of the current items.\n      // Previously it was being done in `componentDidUpdate()`\n      // but it was later found out that it wouldn't work\n      // for \"Show previous\" button because it would\n      // get hidden before `componentDidUpdate()` is called.\n      //\n      // Consider this code example:\n      //\n      // const { fromIndex, items } = this.state\n      // const items = allItems.slice(fromIndex)\n      // return (\n      // \t{fromIndex > 0 &&\n      // \t\t<button onClick={this.onShowPrevious}>\n      // \t\t\tShow previous\n      // \t\t</button>\n      // \t}\n      // \t<VirtualScroller\n      // \t\titems={items}\n      // \t\titemComponent={ItemComponent}/>\n      // )\n      //\n      // Consider a user clicks \"Show previous\" to show the items from the start.\n      // By the time `componentDidUpdate()` is called on `<VirtualScroller/>`\n      // the \"Show previous\" button has already been hidden\n      // which results in the scroll Y position jumping forward\n      // by the height of the \"Show previous\" button.\n      // This is because `<VirtualScroller/>` restores scroll Y position\n      // when items are prepended via `.setItems()` and it does that\n      // when the \"Show previous\" button has already been hidden\n      // so that's the reason for the scroll Y jump.\n      //\n      // To prevent that, scroll Y position is stored at `render()` time\n      // rather than later in `componentDidUpdate()`.\n      //\n\n\n      var newItems = this.props.items;\n      var previousItems = items; // this.virtualScroller.getState().items\n      // There's one case when `newItems !== previousItems` is `true`\n      // from the start: when `initialState.items` are passed.\n      // To handle that single case `this.previousItemsProperty`\n      // is tracked and `this.itemsPropertyHasChanged` flag is set.\n\n      if (!this.itemsPropertyWasChanged) {\n        this.itemsPropertyWasChanged = this.props.items !== this.previousItemsProperty;\n      }\n\n      this.previousItemsProperty = this.props.items;\n\n      if (this.itemsPropertyWasChanged && newItems !== previousItems) {\n        var _getItemsDiff = getItemsDiff(previousItems, newItems),\n            prependedItemsCount = _getItemsDiff.prependedItemsCount,\n            appendedItemsCount = _getItemsDiff.appendedItemsCount;\n\n        if (prependedItemsCount === 0 && appendedItemsCount > 0) {// If it's just items that have been appended\n          // then no need to re-generate the prefix\n          // and to fix scroll position and to clear caches.\n        } else {\n          // `preserveScrollPosition` property name is deprecated,\n          // use `preserveScrollPositionOnPrependItems` instead.\n          if (preserveScrollPositionOnPrependItems || preserveScrollPosition) {\n            this.virtualScroller.captureScroll(previousItems, newItems);\n          } // Reset the unique `key` prefix for item component keys.\n\n\n          this.generateUniquePrefix(); // Reset handler function caches.\n\n          this.onItemStateChange = new Array(newItems.length);\n          this.onItemHeightChange = new Array(newItems.length); // Reset item refs.\n\n          this.itemRefs = new Array(newItems.length);\n        }\n      }\n\n      return React.createElement(\"div\", _extends({}, rest, {\n        ref: this.container,\n        style: {\n          paddingTop: px(beforeItemsHeight),\n          paddingBottom: px(afterItemsHeight)\n        }\n      }), items.map(function (item, i) {\n        if (i >= firstShownItemIndex && i <= lastShownItemIndex) {\n          return React.createElement(Component, _extends({}, itemComponentProps, {\n            ref: _this5.shouldUseRefs() ? _this5.getItemRef(i) : undefined,\n            key: \"\".concat(_this5.uniquePrefix, \":\").concat(i),\n            state: itemStates && itemStates[i],\n            onStateChange: _this5.getOnItemStateChange(i),\n            onHeightChange: _this5.getOnItemHeightChange(i)\n          }), item);\n        }\n\n        return null;\n      }));\n    }\n  }]);\n\n  return ReactVirtualScroller;\n}(React.Component);\n/**\r\n * Checks if the argument is a `React.Component` class.\r\n * https://overreacted.io/how-does-react-tell-a-class-from-a-function/\r\n * @param  {any}  Component\r\n * @return {object} [result] Returns `undefined` if it's not a `React.Component`. Returns an empty object if it's a `React.Component` (`.isReactComponent` is an empty object).\r\n */\n\n\n_defineProperty(ReactVirtualScroller, \"propTypes\", {\n  items: PropTypes.arrayOf(PropTypes.object).isRequired,\n  itemComponent: elementType.isRequired,\n  itemComponentProps: PropTypes.object,\n  estimatedItemHeight: PropTypes.number,\n  bypass: PropTypes.bool,\n  bypassBatchSize: PropTypes.number,\n  preserveScrollPositionOnPrependItems: PropTypes.bool,\n  // `preserveScrollPosition` property name is deprecated,\n  // use `preserveScrollPositionOnPrependItems` instead.\n  preserveScrollPosition: PropTypes.bool,\n  preserveScrollPositionAtBottomOnMount: PropTypes.bool,\n  onMount: PropTypes.func,\n  onItemFirstRender: PropTypes.func,\n  onStateChange: PropTypes.func,\n  initialState: PropTypes.shape({\n    items: PropTypes.arrayOf(PropTypes.object).isRequired,\n    itemStates: PropTypes.arrayOf(PropTypes.any),\n    firstShownItemIndex: PropTypes.number.isRequired,\n    lastShownItemIndex: PropTypes.number.isRequired,\n    beforeItemsHeight: PropTypes.number.isRequired,\n    afterItemsHeight: PropTypes.number.isRequired,\n    itemHeights: PropTypes.arrayOf(PropTypes.number).isRequired,\n    itemSpacing: PropTypes.number\n  }) // `this.state` is already reserved for `virtual-scroller`.\n  // static getDerivedStateFromProps(props, state) {\n  // \treturn {\n  // \t\tprevProps: {\n  // \t\t\titems: props.items\n  // \t\t}\n  // \t}\n  // }\n\n});\n\nexport { ReactVirtualScroller as default };\n\nfunction isComponentClass(Component) {\n  // return Component.prototype instanceof React.Component\n  // `React.memo()` returns `.prototype === undefined` for some reason.\n  return Component.prototype && Component.prototype.isReactComponent;\n}\n//# sourceMappingURL=ReactVirtualScroller.js.map"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","hasOwnProperty","Object","is","x","y","shallowEqual","objA","objB","keysA","keys","keysB","length","i","call","getOffset","element","onScreenCoordinates","getBoundingClientRect","documentLeftBorderWidth","document","clientLeft","body","documentTopBorderWidth","clientTop","scrollY","window","pageYOffset","scrollX","pageXOffset","top","left","width","height","getScrollY","getScreenHeight","innerHeight","_toConsumableArray","arr","Array","isArray","arr2","_arrayWithoutHoles","iter","toString","from","_iterableToArray","TypeError","_nonIterableSpread","log","isDebug","_console","_len","arguments","args","_key","console","apply","concat","VirtualScrollerDebug","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","ItemHeights","getContainerNode","getState","instance","Constructor","_classCallCheck","this","reset","protoProps","staticProps","value","measuredItemsHeight","firstMeasuredItemIndex","undefined","lastMeasuredItemIndex","itemHeights","firstShownItemIndex","container","nodeIndex","childNodes","firstItem","secondItem","firstItemRect","spacing","fromIndex","toIndex","itemSpacing","getItemSpacing","previousFirstMeasuredItemIndex","previousLastMeasuredItemIndex","firstMeasuredItemIndexHasBeenUpdated","_getItemHeight","set","previousHeight","get","count","px","number","toFixed","_objectSpread","source","ownKeys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","forEach","_defineProperty","WINDOW_RESIZE_THROTTLE_DURATION","VirtualScroller","items","func","interval","timeout","executedAt","scheduled","_this","options","onUpdateShownItemIndexes","reason","setState","getInitialLayoutState","onInitialRender","Date","now","remaining","clearTimeout","setTimeout","callback","_this$getShownItemInd","getShownItemIndexes","lastShownItemIndex","redoLayoutAfterRender","beforeItemsHeight","getBeforeItemsHeight","afterItemsHeight","getAfterItemsHeight","updateWillBeHiddenItemHeightsAndState","bypass","getAverage","slice","itemStates","onShowItems","updateShownItemIndexes","isMounted","updateShownItemIndexesRecursive","onDoneUpdatingItemIndexes","_this$restoreScrollAf","restoreScrollAfterPrepend","index","screenTop","scrollByY","getItemElement","scrollTo","_ref","force","getItemsCount","isUpdatingItemIndexes","onUserStopsScrollingTimeout","forceRender","latestLayoutScreenTopAfterMargin","latestLayoutScreenBottomAfterMargin","onUserStoppedScrolling","updateLayout","onStateChange","preserveScrollPositionAtBottomOnMount","bypassBatchSize","estimatedItemHeight","onItemFirstRender","state","initialItems","firstChild","removeChild","clearElement","prevState","onUpdate","documentHeight","documentElement","scrollHeight","getInitialState","onInitItemHeights","customState","itemsCount","Math","min","getLastShownItemIndex","getEstimatedItemHeight","ceil","getEstimatedItemsCount","getEstimatedItemsCountOnScreen","firstSeenItemIndex","_i","lastSeenItemIndex","_i2","addEventListener","onScroll","onResize","_this$getState","updateItemHeights","removeEventListener","watchContainerElementTopCoordinateTimer","_this$getState2","update","updateItemHeight","itemState","JSON","stringify","newHeight","j","bottom","screenBottom","listTop","showItemsFromIndex","showItemsToIndex","itemsHeight","heightLeft","getOffscreenListShownItemIndexes","indexes","getVisibleItemIndexes","_this2","startedAt","check","_getOffset3","watchContainerElementTopCoordinate","_getScreenBounds","getScreenBounds","getMargin","getItemIndexes","restoreScroll","previousItems","nextItems","firstPreviousItemIndex","indexOf","newItems","setItems","_this3","_this$getState9","_getItemsDiff","getItemsDiff","prependedItemsCount","appendedItemsCount","isIncrementalUpdate","onPrepend","preserveScrollPositionOnPrependItems","preserveScrollPosition","captureScroll","lastPreviousItemIndex","offset","arePreviousItemsPreserved","_extends","assign","_objectWithoutProperties","excluded","sourceKeys","_objectWithoutPropertiesLoose","sourceSymbolKeys","propertyIsEnumerable","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","p","elementType","PropTypes","oneOfType","object","ReactVirtualScroller","_React$Component","React","createRef","virtualScroller","layout","_this$props","initialState","previousItemsProperty","current","newState","generateUniquePrefix","subClass","superClass","create","_inherits","Component","itemComponent","isReactComponent","getItemCoordinates","renderItem","shouldUseRefs","error","itemRefs","item","forceUpdate","_isMounted","onItemHeightChange","onItemStateChange","_this4","prefix","String","random","uniquePrefixes","push","uniquePrefix","onMount","prevProps","_this$props2","onUnmount","_this5","_this$props3","itemComponentProps","rest","_this$virtualScroller","itemsPropertyWasChanged","createElement","ref","style","paddingTop","paddingBottom","map","getItemRef","getOnItemStateChange","onHeightChange","getOnItemHeightChange","arrayOf","isRequired","bool","shape","any"],"mappings":"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"}